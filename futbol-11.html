<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fútbol 11 Táctico Interactivo</title>
    
    <style>
        :root {
            /* Colores principales */
            --color-background: #1a1a1a;
            --color-surface: #2c2c2c;
            --color-primary: #007bff;
            --color-secondary: #6c757d;
            --color-success: #28a745;
            --color-danger: #dc3545;
            --color-warning: #ffc107;
            --color-text: #f8f9fa;
            --color-pitch: #006400;
            --color-pitch-lines: rgba(255, 255, 255, 0.7);
            
            /* Sombras y efectos */
            --shadow-sm: 0 2px 5px rgba(0, 0, 0, 0.2);
            --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.3);
            --shadow-lg: 0 8px 20px rgba(0, 0, 0, 0.4);
            
            /* Transiciones */
            --transition-fast: 0.15s ease;
            --transition-normal: 0.2s ease;
            --transition-slow: 0.3s ease;
            
            /* Border radius */
            --radius-sm: 6px;
            --radius-md: 8px;
            --radius-lg: 12px;
        }
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        html, body {
            width: 100%; height: 100%; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--color-background); color: var(--color-text);
        }
        /* MEJORA: Se aumenta el ancho máximo para aprovechar mejor la pantalla */
        main { padding: 15px; max-width: 1200px; margin: 0 auto; }
        section {
            background-color: var(--color-surface);
            padding: 20px;
            border-radius: var(--radius-lg);
            margin-bottom: 20px;
            box-shadow: var(--shadow-md);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        h2 { font-size: 1.4em; border-bottom: 2px solid var(--color-primary); padding-bottom: 10px; margin-bottom: 15px; }
        #app-header { display: none; text-align: center; }
        #marcador {
            font-size: 2em; font-weight: bold; display: flex; align-items: center; justify-content: space-between;
            gap: 15px; background: rgba(0,0,0,0.2); padding: 10px 20px; border-radius: 8px;
        }
        .team-info { flex: 1; display: flex; align-items: center; gap: 10px; font-size: 0.8em; }
        .team-info.local { justify-content: flex-end; } .team-info.rival { justify-content: flex-start; }
        #tiempo { display: flex; align-items: center; justify-content: center; margin-top: 15px; gap: 10px; }
        #minuto-actual { 
            font-size: 1.3em; font-weight: bold; background: #111; border: 1px solid #555; 
            padding: 8px 12px; border-radius: 6px; width: 90px; text-align: center;
        }
        button {
            padding: 12px 18px;
            border: none;
            border-radius: var(--radius-md);
            font-size: 1em;
            cursor: pointer;
            font-weight: bold;
            transition: all var(--transition-normal);
            box-shadow: var(--shadow-sm);
        }
        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }
        button:active:not(:disabled) {
            transform: translateY(0);
        }
        button:disabled {
            background-color: #444 !important;
            color: #888 !important;
            cursor: not-allowed;
            opacity: 0.7;
            border-color: #444 !important;
        }
        .btn-primary { background: linear-gradient(145deg, var(--color-primary), #0056b3); color: white; }
        .btn-secondary { background: var(--color-secondary); color: white; }
        .btn-danger { background: linear-gradient(145deg, var(--color-danger), #a71d2a); color: white; }
        .btn-warning { background: linear-gradient(145deg, var(--color-warning), #e0a800); color: #000; }
        .btn-event { background-color: transparent; color: var(--color-warning); border: 2px solid var(--color-warning); }
        .control-group, .event-group { display: grid; grid-template-columns: repeat(auto-fit, minmax(130px, 1fr)); gap: 10px; margin-top: 15px; }
        label { display: block; margin-top: 15px; margin-bottom: 5px; font-weight: bold; }
        input, textarea { width: 100%; padding: 12px; margin-bottom: 10px; border: 1px solid #555; background-color: #333; color: var(--color-text); border-radius: 6px; font-size: 1em; }
        #pitch-section { position: relative; }
        #event-flow-message { position: absolute; top: 10px; left: 50%; width: 90%; max-width: 400px; transform: translateX(-50%); background-color: rgba(0,0,0,0.9); color: white; padding: 12px 22px; border-radius: 25px; z-index: 1001; font-size: 1em; border: 1px solid var(--color-primary); box-shadow: 0 4px 8px rgba(0,0,0,0.5); text-align: center; cursor: pointer; }
        .selecting-mode { cursor: crosshair !important; }
        #futsal-pitch { position: relative; width: 100%; aspect-ratio: 105 / 68; background-color: var(--color-pitch); border: 3px solid var(--color-pitch-lines); box-shadow: inset 0 0 15px rgba(0,0,0,0.5); }
        .soccer-pitch-lines svg { width: 100%; height: 100%; }
        #bench-container { display: flex; margin-top: 15px; gap: 15px; }
        .bench { width: 50%; min-height: 100px; border: 2px dashed #555; border-radius: 8px; padding: 10px; display: flex; flex-wrap: wrap; gap: 6px; align-content: flex-start; justify-content: center; background: rgba(0,0,0,0.2); }
        
        .player-chip {
            width: 30px; height: 30px; 
            border-radius: 50%; color: white; display: flex; align-items: center; justify-content: center;
            font-weight: bold; font-size: 10px; 
            cursor: grab; user-select: none; border: 2px solid white;
            box-shadow: 0 3px 6px rgba(0,0,0,0.5); transition: box-shadow 0.2s, transform 0.2s; position: relative;
            touch-action: none;
        }
        .chip-local { background-color: var(--color-primary); } .chip-rival { background-color: var(--color-danger); }
        .chip-on-bench { position: static; } .chip-on-pitch { position: absolute; z-index: 10; transform: translate(-50%, -50%);}
        
        .dragging {
            cursor: grabbing;
            opacity: 0.7;
            transform: scale(1.15); 
            z-index: 1000 !important;
            position: fixed !important; 
            box-shadow: 0 8px 20px rgba(0,0,0,0.6) !important;
        }
        
        .expulsado { filter: grayscale(100%); cursor: not-allowed !important; opacity: 0.5; }
        .expulsado::after {
            content: '🟥'; position: absolute; top: -5px; right: -5px; font-size: 14px;
            line-height: 1; text-shadow: 0 0 3px black;
        }
        .sustituido {
            background-color: var(--color-secondary) !important; filter: grayscale(80%);
            cursor: not-allowed !important; opacity: 0.7; border-color: #555;
        }
        table { width: 100%; border-collapse: collapse; margin-top: 15px; font-size: 0.9em; table-layout: fixed;}
        th, td { padding: 10px; text-align: center; border-bottom: 1px solid #444; }
        thead { background-color: rgba(0,0,0,0.3); }
        tbody tr:hover { background-color: rgba(255, 255, 255, 0.05); }
        .player-on-pitch { background-color: rgba(0, 123, 255, 0.2); font-weight: bold; }
        .modal { z-index: 2000; display: none; align-items: center; justify-content: center; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); }
        .modal.visible { display: flex; }
        .modal-content { background: var(--color-surface); box-shadow: 0 5px 15px rgba(0,0,0,0.5); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 12px; padding: 20px; width: 90%; max-width: 500px; }
        #formation-buttons { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; margin: 20px 0; }
        .hidden { display: none !important; }
        #match-stats-section .stat-grid { display: flex; flex-direction: column; gap: 12px; margin-top: 15px; }
        .stat-row { display: grid; grid-template-columns: 50px 1fr 50px; align-items: center; text-align: center; font-weight: bold; }
        .stat-value { font-size: 1.4em; }
        .stat-bar-container { padding: 0 15px; }
        .stat-bar-container span { font-size: 0.9em; text-transform: uppercase; letter-spacing: 0.5px; opacity: 0.8; }
        .stat-bar { background-color: #111; border-radius: 5px; height: 12px; width: 100%; display: flex; overflow: hidden; margin-top: 4px; border: 1px solid #444; }
        .stat-bar-local { background-color: var(--color-primary); height: 100%; transition: width 0.5s ease; }
        #possession-controls { display: flex; justify-content: center; align-items: center; gap: 10px; margin-top: 20px; background-color: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px; }
        .btn-possession { flex: 1; padding: 8px; border: 2px solid transparent; background-color: var(--color-secondary); }
        .btn-possession.active { border-color: var(--color-warning); box-shadow: 0 0 10px var(--color-warning); }

        @media (max-width: 768px) {
            main { padding: 10px; max-width: 100%; } /* Ajuste para móvil */
            section { padding: 15px; }
            .player-chip { width: 26px; height: 26px; font-size: 9px; } 
            #marcador { font-size: 1.5em; } .team-info { font-size: 0.7em; }
            .event-group { grid-template-columns: 1fr 1fr; }
        }
    </style>
</head>
<body>
    <main>
        <section id="config-section">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2 style="margin: 0;">Configuración del Partido</h2>
                <button id="btn-home" class="btn-secondary" style="display: flex; align-items: center; gap: 8px; padding: 10px 15px;">
                    <span style="font-size: 1.2em;">🏠</span>
                    <span>Menú Principal</span>
                </button>
            </div>
            <label for="local-name-input">Nombre Equipo Local:</label>
            <input type="text" id="local-name-input" value="Equipo Local">
            <label for="rival-name">Nombre Rival:</label>
            <input type="text" id="rival-name" value="Equipo Rival">
            <label for="local-players">Jugadores Locales (Dorsales separados por coma):</label>
            <textarea id="local-players" rows="3">1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25</textarea>
            <label for="rival-dorsals">Dorsales Rivales (separados por coma):</label>
            <textarea id="rival-dorsals" rows="3">1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25</textarea>
            <button id="start-config" class="btn-primary">Guardar y Preparar Pizarra</button>
        </section>

        <header id="app-header">
            <div id="marcador">
                <div class="team-info local"><span id="local-name"></span></div>
                <div class="score-display"><span id="local-score">0</span> - <span id="rival-score">0</span></div>
                <div class="team-info rival"><span id="rival-name-display"></span></div>
            </div>
            <div id="tiempo">
                <button id="btn-toggle-timer" class="btn-primary" disabled>Ajusta Alineaciones</button>
                <input type="text" id="minuto-actual" value="00:00" readonly>
            </div>
        </header>

        <section id="pitch-section" class="hidden">
            <h2>Pizarra Táctica</h2>
            <div id="event-flow-message" class="hidden"></div>
            <div id="futsal-pitch">
                <div class="soccer-pitch-lines"><svg viewBox="0 0 105 68" preserveAspectRatio="xMidYMid meet"><rect x="0" y="0" width="105" height="68" stroke="var(--color-pitch-lines)" stroke-width="0.3" fill="none"/><line x1="52.5" y1="0" x2="52.5" y2="68" stroke="var(--color-pitch-lines)" stroke-width="0.3"/><circle cx="52.5" cy="34" r="9.15" stroke="var(--color-pitch-lines)" stroke-width="0.3" fill="none"/><circle cx="52.5" cy="34" r="0.4" fill="var(--color-pitch-lines)"/><rect x="0" y="13.84" width="16.5" height="40.32" stroke="var(--color-pitch-lines)" stroke-width="0.3" fill="none"/><rect x="0" y="24.84" width="5.5" height="18.32" stroke="var(--color-pitch-lines)" stroke-width="0.3" fill="none"/><circle cx="11" cy="34" r="0.4" fill="var(--color-pitch-lines)"/><path d="M 16.5 26.69 A 9.15 9.15 0 0 1 16.5 41.31" stroke="var(--color-pitch-lines)" stroke-width="0.3" fill="none"/><rect x="88.5" y="13.84" width="16.5" height="40.32" stroke="var(--color-pitch-lines)" stroke-width="0.3" fill="none"/><rect x="99.5" y="24.84" width="5.5" height="18.32" stroke="var(--color-pitch-lines)" stroke-width="0.3" fill="none"/><circle cx="94" cy="34" r="0.4" fill="var(--color-pitch-lines)"/><path d="M 88.5 26.69 A 9.15 9.15 0 0 0 88.5 41.31" stroke="var(--color-pitch-lines)" stroke-width="0.3" fill="none"/><path d="M 0 1 A 1 1 0 0 1 1 0" stroke="var(--color-pitch-lines)" stroke-width="0.3" fill="none"/><path d="M 104 0 A 1 1 0 0 1 105 1" stroke="var(--color-pitch-lines)" stroke-width="0.3" fill="none"/><path d="M 0 67 A 1 1 0 0 0 1 68" stroke="var(--color-pitch-lines)" stroke-width="0.3" fill="none"/><path d="M 104 68 A 1 1 0 0 0 105 67" stroke="var(--color-pitch-lines)" stroke-width="0.3" fill="none"/></svg></div>
            </div>
            <div id="bench-container"><div id="local-bench" class="bench"></div><div id="rival-bench" class="bench"></div></div>
        </section>

        <section id="game-controls" class="hidden">
             <div class="event-group">
                <button class="btn-event" data-event="goal">GOL ⚽</button><button class="btn-event" data-event="shot-on-goal">TIRO A PUERTA 🎯</button>
                <button class="btn-event" data-event="shot">DISPARO 💥</button><button class="btn-event" data-event="corner">CÓRNER ⛳</button>
                <button class="btn-event" data-event="offside">FUERA DE JUEGO 🏳️</button>
                <button class="btn-event" data-event="foul">FALTA ✋</button><button class="btn-event" data-event="yellow-card">AMARILLA 🟨</button>
                <button class="btn-event" data-event="red-card">ROJA 🟥</button>
            </div>
            <div id="possession-controls" class="possession-controls">
                <span>Posesión:</span>
                <button id="possession-local" class="btn-possession"></button>
                <button id="possession-rival" class="btn-possession"></button>
            </div>
            <div class="control-group">
                <button id="btn-half-time" class="btn-secondary" disabled>Descanso</button><button id="btn-start-second" class="btn-secondary" disabled>Inicio 2ª</button>
                <button id="btn-finish-game" class="btn-danger" disabled>Finalizar</button>
            </div>
        </section>
        
        <section id="timeline-section" class="hidden">
            <h2>Cronología del Partido</h2>
            <div id="event-timeline" style="max-height: 200px; overflow-y: auto; padding-right: 10px;"></div>
        </section>

        <section id="match-stats-section" class="hidden">
            <h2>Estadísticas del Partido</h2>
            <div class="stat-grid">
                <div class="stat-row"><span class="stat-value local-stat" id="stat-local-possession">50%</span><div class="stat-bar-container"><span>Posesión</span><div class="stat-bar"><div class="stat-bar-local" id="stat-bar-possession" style="width: 50%;"></div></div></div><span class="stat-value rival-stat" id="stat-rival-possession">50%</span></div>
                <div class="stat-row"><span class="stat-value local-stat" id="stat-local-shots">0</span><div class="stat-bar-container"><span>Disparos</span><div class="stat-bar"><div class="stat-bar-local" id="stat-bar-shots" style="width: 50%;"></div></div></div><span class="stat-value rival-stat" id="stat-rival-shots">0</span></div>
                <div class="stat-row"><span class="stat-value local-stat" id="stat-local-sot">0</span><div class="stat-bar-container"><span>Tiros a Puerta</span><div class="stat-bar"><div class="stat-bar-local" id="stat-bar-sot" style="width: 50%;"></div></div></div><span class="stat-value rival-stat" id="stat-rival-sot">0</span></div>
                <div class="stat-row"><span class="stat-value local-stat" id="stat-local-corners">0</span><div class="stat-bar-container"><span>Córners</span><div class="stat-bar"><div class="stat-bar-local" id="stat-bar-corners" style="width: 50%;"></div></div></div><span class="stat-value rival-stat" id="stat-rival-corners">0</span></div>
                <div class="stat-row"><span class="stat-value local-stat" id="stat-local-offsides">0</span><div class="stat-bar-container"><span>Fueras de Juego</span><div class="stat-bar"><div class="stat-bar-local" id="stat-bar-offsides" style="width: 50%;"></div></div></div><span class="stat-value rival-stat" id="stat-rival-offsides">0</span></div>
                <div class="stat-row"><span class="stat-value local-stat" id="stat-local-yellow">0</span><div class="stat-bar-container"><span>Tarjetas Amarillas</span><div class="stat-bar"><div class="stat-bar-local" id="stat-bar-yellow" style="width: 50%;"></div></div></div><span class="stat-value rival-stat" id="stat-rival-yellow">0</span></div>
                <div class="stat-row"><span class="stat-value local-stat" id="stat-local-red">0</span><div class="stat-bar-container"><span>Tarjetas Rojas</span><div class="stat-bar"><div class="stat-bar-local" id="stat-bar-red" style="width: 50%;"></div></div></div><span class="stat-value rival-stat" id="stat-rival-red">0</span></div>
            </div>
        </section>
        
        <section id="stats-section" class="hidden">
            <h2>Estadísticas de Jugadores</h2>
            <h3 id="local-stats-title"></h3>
            <table id="local-stats-table"><thead><tr><th>Jugador</th><th>G</th><th>A</th><th>D</th><th>TP</th><th>F</th><th>🟨</th><th>🟥</th><th>MIN</th></tr></thead><tbody></tbody></table>
            <h3 id="rival-stats-title" style="margin-top: 20px;"></h3>
            <table id="rival-stats-table"><thead><tr><th>Dorsal</th><th>G</th><th>A</th><th>D</th><th>TP</th><th>F</th><th>🟨</th><th>🟥</th><th>MIN</th></tr></thead><tbody></tbody></table>
            <div class="control-group" style="margin-top: 20px;">
                <button id="btn-reset-match" class="btn-secondary">Reiniciar</button>
                <button id="btn-new-match" class="btn-secondary">Nuevo Partido</button>
                <button id="btn-repair-state" class="btn-warning" title="Reparar estado de jugadores">🔧 Reparar Estado</button>
            </div>
            <button id="btn-export-excel" class="btn-primary hidden" style="margin-top: 20px; width: 100%;">Exportar a Excel</button>
        </section>
        
        <div id="formation-modal" class="modal">
            <div class="modal-content"><h3 id="formation-modal-title"></h3><div id="formation-buttons"></div><button id="skip-formation" class="btn-secondary">Colocar Manualmente</button></div>
        </div>
    </main>

<script>
    'use strict';
    
    // --- 1. CONFIGURACIÓN Y CONSTANTES GLOBALES ---
    const AppConfig = {
        HALF_TIME_SECONDS: 45 * 60,
        FULL_TIME_SECONDS: 90 * 60,
        FIRST_HALF_MAX_TIME: 55 * 60,
        SECOND_HALF_MAX_TIME: 105 * 60,
        MAX_PLAYERS_ON_PITCH: 11,
        APP_STATE_KEY: 'futsalTacticoState_vFinal_Refactored',
        // MEJORA: Coordenadas de formación reajustadas para mejor espaciado
        FORMATIONS: {
            '1-4-4-2':     [{x:5,y:50},{x:22,y:15},{x:22,y:37},{x:22,y:63},{x:22,y:85},{x:36,y:15},{x:36,y:37},{x:36,y:63},{x:36,y:85},{x:45,y:40},{x:45,y:60}],
            '1-4-3-3':     [{x:5,y:50},{x:22,y:15},{x:22,y:37},{x:22,y:63},{x:22,y:85},{x:35,y:25},{x:35,y:50},{x:35,y:75},{x:44,y:15},{x:46,y:50},{x:44,y:85}],
            '1-4-5-1':     [{x:5,y:50},{x:22,y:15},{x:22,y:37},{x:22,y:63},{x:22,y:85},{x:34,y:50},{x:36,y:15},{x:36,y:35},{x:36,y:65},{x:36,y:85},{x:45,y:50}],
            '1-4-2-3-1':   [{x:5,y:50},{x:22,y:15},{x:22,y:37},{x:22,y:63},{x:22,y:85},{x:32,y:35},{x:32,y:65},{x:42,y:15},{x:42,y:50},{x:42,y:85},{x:46,y:50}],
            '1-4-1-2-1-2': [{x:5,y:50},{x:22,y:15},{x:22,y:37},{x:22,y:63},{x:22,y:85},{x:30,y:50},{x:36,y:30},{x:36,y:70},{x:42,y:50},{x:46,y:35},{x:46,y:65}],
            '1-3-4-3':     [{x:5,y:50},{x:22,y:25},{x:22,y:50},{x:22,y:75},{x:34,y:15},{x:34,y:40},{x:34,y:60},{x:34,y:85},{x:45,y:20},{x:45,y:50},{x:45,y:80}],
            '1-3-5-2':     [{x:5,y:50},{x:22,y:25},{x:22,y:50},{x:22,y:75},{x:36,y:10},{x:34,y:35},{x:34,y:65},{x:36,y:90},{x:33,y:50},{x:45,y:40},{x:45,y:60}],
            '1-5-3-2':     [{x:5,y:50},{x:20,y:50},{x:22,y:25},{x:22,y:75},{x:24,y:10},{x:24,y:90},{x:36,y:25},{x:36,y:50},{x:36,y:75},{x:45,y:40},{x:45,y:60}],
        }
    };

    // --- 2. GESTIÓN DEL ESTADO DE LA APLICACIÓN ---
    const AppState = {
        _state: {},
        getInitial() {
            return {
                localTeamName: 'Local', rivalTeamName: 'Rival', localPlayers: [], rivalDorsals: [],
                playerStats: { local: {}, rival: {} },
                matchStats: { local: { corners: 0, offsides: 0 }, rival: { corners: 0, offsides: 0 } },
                possession: { team: null, startTime: 0, localSeconds: 0, rivalSeconds: 0 },
                matchTimer: 0, timerStartTime: 0, timerBaseTime: 0, currentHalf: 1, isMatchRunning: false, timerInterval: null, 
                lastMinuteCheck: -1, matchEvents: [], eventFlow: { active: false },
                eliminatedPlayers: { local: [], rival: [] }
            };
        },
        init() { this._state = this.getInitial(); },
        load() {
            const savedStateJSON = localStorage.getItem(AppConfig.APP_STATE_KEY);
            if (!savedStateJSON) return false;
            try {
                const loadedState = JSON.parse(savedStateJSON);
                delete loadedState.timerInterval;
                this._state = { ...this.getInitial(), ...loadedState };
                // Asegurar que eliminatedPlayers existe
                if (!this._state.eliminatedPlayers) {
                    this._state.eliminatedPlayers = { local: [], rival: [] };
                }
                return true;
            } catch (e) {
                console.error("Error al cargar estado, reseteando.", e);
                localStorage.removeItem(AppConfig.APP_STATE_KEY);
                return false;
            }
        },
        save() { 
            const stateToSave = {...this._state};
            delete stateToSave.timerInterval;
            localStorage.setItem(AppConfig.APP_STATE_KEY, JSON.stringify(stateToSave)); 
        },
        get() { return this._state; },
        set(newState) { this._state = newState; }
    };

    // --- 3. MANIPULACIÓN DEL DOM Y ACTUALIZACIONES DE UI ---
    const DOM = {
        elements: {},
        cacheElements() {
            const ids = [
                'config-section', 'app-header', 'pitch-section', 'game-controls', 'timeline-section',
                'match-stats-section', 'stats-section', 'local-name-input', 'rival-name',
                'local-players', 'rival-dorsals', 'start-config', 'btn-home', 'btn-toggle-timer', 'minuto-actual',
                'futsal-pitch', 'local-bench', 'rival-bench', 'event-timeline', 'formation-modal',
                'formation-modal-title', 'formation-buttons', 'skip-formation', 'event-flow-message',
                'possession-local', 'possession-rival', 'btn-half-time', 'btn-start-second',
                'btn-finish-game', 'btn-reset-match', 'btn-new-match', 'btn-export-excel',
                'local-name', 'rival-name-display', 'local-score', 'rival-score',
                'local-stats-title', 'rival-stats-title', 'local-stats-table', 'rival-stats-table',
                'possession-controls', 'btn-repair-state'
            ];
            ids.forEach(id => this.elements[id] = document.getElementById(id));
            this.elements.eventButtons = document.querySelectorAll('.btn-event');
        },
        showMatchUI() {
            this.elements['config-section'].classList.add('hidden');
            this.elements['app-header'].style.display = 'block';
            ['pitch-section', 'game-controls', 'timeline-section', 'match-stats-section', 'stats-section']
                .forEach(id => this.elements[id].classList.remove('hidden'));
        },
        updateAll() {
            const state = AppState.get();
            this.elements['local-name'].textContent = state.localTeamName;
            this.elements['rival-name-display'].textContent = state.rivalTeamName;
            this.elements['local-stats-title'].textContent = state.localTeamName;
            this.elements['rival-stats-title'].textContent = state.rivalTeamName;
            this.elements['possession-local'].textContent = state.localTeamName;
            this.elements['possession-rival'].textContent = state.rivalTeamName;
            
            // Diagnóstico y reparación automática de inconsistencias
            this.diagnoseAndRepairPlayerState();
            
            this.updateTimerDisplay();
            this.updateButtonStates();
            this.updateScoreboard();
            this.updatePlayerChips();
            this.updateStatsTables();
            this.updateMatchStats();
            this.renderTimeline();
            this.updateDocumentTitle();
        },
        setupBenchesAndPitch() {
            const state = AppState.get();
            this.elements['local-bench'].innerHTML = ''; 
            this.elements['rival-bench'].innerHTML = '';
            this.elements['futsal-pitch'].querySelectorAll('.player-chip').forEach(chip => chip.remove());
            
            // Solo crear chips para jugadores que no están eliminados
            state.localPlayers.forEach(p => {
                if (!state.eliminatedPlayers.local.includes(p)) {
                    this.elements['local-bench'].appendChild(this.createChip(p, 'local'));
                }
            });
            state.rivalDorsals.forEach(d => {
                if (!state.eliminatedPlayers.rival.includes(d)) {
                    this.elements['rival-bench'].appendChild(this.createChip(d, 'rival'));
                }
            });
        },
        createChip(name, team) {
            const chip = document.createElement('div');
            chip.className = `player-chip chip-${team}`;
            chip.textContent = name;
            chip.dataset.name = name;
            chip.dataset.team = team;
            chip.addEventListener('pointerdown', DragAndDrop.start.bind(DragAndDrop));
            chip.addEventListener('click', () => {
                if (AppState.get().eventFlow.active) EventHandler.processEventSelection(chip);
            });
            
            // Agregar funcionalidad de eliminación (solo antes de iniciar partido)
            let longPressTimer;
            chip.addEventListener('pointerdown', (e) => {
                const state = AppState.get();
                if (state.matchEvents.length > 0) return; // Solo antes de iniciar
                if (chip.classList.contains('chip-on-pitch')) return; // Solo jugadores del banquillo
                
                longPressTimer = setTimeout(() => {
                    this.showDeletePlayerModal(name, team, chip);
                }, 1000); // 1 segundo de presión
            });
            
            chip.addEventListener('pointerup', () => {
                clearTimeout(longPressTimer);
            });
            
            chip.addEventListener('pointerleave', () => {
                clearTimeout(longPressTimer);
            });
            
            return chip;
        },
        showDeletePlayerModal(playerName, team, chip) {
            const state = AppState.get();
            const teamName = team === 'local' ? state.localTeamName : state.rivalTeamName;
            const confirmMessage = `¿Eliminar a ${playerName} del equipo ${teamName}?\n\nEsta acción no se puede deshacer.`;
            
            if (confirm(confirmMessage)) {
                this.deletePlayer(playerName, team, chip);
            }
        },
        deletePlayer(playerName, team, chip) {
            const state = AppState.get();
            
            // Eliminar del estado
            delete state.playerStats[team][playerName];
            
            // Eliminar de las listas de jugadores
            if (team === 'local') {
                state.localPlayers = state.localPlayers.filter(p => p !== playerName);
            } else {
                state.rivalDorsals = state.rivalDorsals.filter(d => d !== playerName);
            }
            
            // Eliminar del DOM
            chip.remove();
            
            // Actualizar estadísticas
            this.updateStatsTables();
            AppState.save();
            
            // Mostrar mensaje de confirmación
            const teamName = team === 'local' ? state.localTeamName : state.rivalTeamName;
            alert(`${playerName} ha sido eliminado del equipo ${teamName}.`);
        },
        updatePlayerChips() {
            const state = AppState.get();
            Object.keys(state.playerStats).forEach(team => {
                Object.keys(state.playerStats[team]).forEach(playerName => {
                    const stats = state.playerStats[team][playerName];
                    const chip = document.querySelector(`.player-chip[data-name="${playerName}"][data-team="${team}"]`);
                    if (!chip || chip.classList.contains('dragging')) return;
                    chip.classList.toggle('expulsado', stats.expulsado);
                    chip.classList.toggle('sustituido', stats.haSidoSustituido && !stats.expulsado);
                    const targetParent = stats.onPitch ? this.elements['futsal-pitch'] : this.elements[`${team}-bench`];
                    if (chip.parentElement !== targetParent) targetParent.appendChild(chip);
                    chip.className = `player-chip chip-${team}`;
                    if (stats.onPitch) {
                        chip.classList.add('chip-on-pitch');
                        Object.assign(chip.style, stats.position);
                    } else {
                        chip.classList.add('chip-on-bench');
                        chip.style.cssText = '';
                    }
                    if (stats.expulsado) chip.classList.add('expulsado');
                    if (stats.haSidoSustituido && !stats.expulsado) chip.classList.add('sustituido');
                });
            });
        },
        
        // Función de diagnóstico y reparación de inconsistencias
        diagnoseAndRepairPlayerState() {
            const state = AppState.get();
            const issues = [];
            
            // Verificar jugadores que están en el campo pero no tienen posición
            Object.keys(state.playerStats).forEach(team => {
                Object.keys(state.playerStats[team]).forEach(playerName => {
                    const player = state.playerStats[team][playerName];
                    const chip = document.querySelector(`.player-chip[data-name="${playerName}"][data-team="${team}"]`);
                    
                    if (player.onPitch && !player.position) {
                        issues.push(`${playerName} está en el campo pero sin posición`);
                        // Reparar: poner en el banquillo
                        player.onPitch = false;
                        player.position = null;
                    }
                    
                    if (player.onPitch && !chip) {
                        issues.push(`${playerName} está en el campo pero no tiene chip en el DOM`);
                        // Reparar: crear chip
                        const newChip = this.createChip(playerName, team);
                        this.elements['futsal-pitch'].appendChild(newChip);
                    }
                    
                    if (!player.onPitch && chip && chip.classList.contains('chip-on-pitch')) {
                        issues.push(`${playerName} está en el banquillo pero su chip está en el campo`);
                        // Reparar: mover chip al banquillo
                        this.elements[`${team}-bench`].appendChild(chip);
                        chip.classList.remove('chip-on-pitch');
                        chip.classList.add('chip-on-bench');
                        chip.style.cssText = '';
                    }
                });
            });
            
            // Detectar y reparar superposiciones de jugadores
            this.detectAndFixOverlappingPlayers();
            
            if (issues.length > 0) {
                console.warn('Problemas detectados en el estado de jugadores:', issues);
                console.log('Reparando inconsistencias...');
                this.updatePlayerChips();
                AppState.save();
                return true; // Se encontraron y repararon problemas
            }
            
            return false; // No se encontraron problemas
        },
        
        // Función para detectar y corregir jugadores superpuestos
        detectAndFixOverlappingPlayers() {
            const state = AppState.get();
            const playersOnPitch = [];
            
            // Recopilar todos los jugadores en el campo
            Object.keys(state.playerStats).forEach(team => {
                Object.keys(state.playerStats[team]).forEach(playerName => {
                    const player = state.playerStats[team][playerName];
                    if (player.onPitch && player.position) {
                        playersOnPitch.push({
                            name: playerName,
                            team: team,
                            position: player.position,
                            player: player
                        });
                    }
                });
            });
            
            // Detectar superposiciones (misma posición exacta)
            const overlappingGroups = [];
            const processed = new Set();
            
            playersOnPitch.forEach((player1, i) => {
                if (processed.has(player1.name)) return;
                
                const group = [player1];
                processed.add(player1.name);
                
                playersOnPitch.forEach((player2, j) => {
                    if (i !== j && !processed.has(player2.name)) {
                        if (player1.position.left === player2.position.left && 
                            player1.position.top === player2.position.top) {
                            group.push(player2);
                            processed.add(player2.name);
                        }
                    }
                });
                
                if (group.length > 1) {
                    overlappingGroups.push(group);
                }
            });
            
            // Reparar superposiciones
            overlappingGroups.forEach(group => {
                console.warn(`Superposición detectada: ${group.map(p => p.name).join(', ')}`);
                
                // Mantener el primer jugador en su posición original
                const firstPlayer = group[0];
                
                // Reposicionar los demás jugadores ligeramente
                group.slice(1).forEach((player, index) => {
                    const originalLeft = parseFloat(firstPlayer.position.left);
                    const originalTop = parseFloat(firstPlayer.position.top);
                    
                    // Calcular nueva posición con pequeño desplazamiento
                    const offset = (index + 1) * 2; // 2% de separación
                    const newLeft = Math.min(95, originalLeft + offset);
                    const newTop = Math.min(95, originalTop + offset);
                    
                    player.player.position = {
                        left: `${newLeft}%`,
                        top: `${newTop}%`
                    };
                    
                    console.log(`Reposicionando ${player.name} a ${newLeft}%, ${newTop}%`);
                });
            });
            
            if (overlappingGroups.length > 0) {
                console.log(`Se repararon ${overlappingGroups.length} superposiciones`);
                // Actualizar el estado inicial para conservar las correcciones
                state.initialPlayerState = JSON.parse(JSON.stringify(state.playerStats));
                AppState.save();
            }
        },
        
        updateScoreboard() {
            const state = AppState.get();
            let localScore = 0, rivalScore = 0;
            Object.values(state.playerStats.local).forEach(p => localScore += p.goles);
            Object.values(state.playerStats.rival).forEach(p => rivalScore += p.goles);
            this.elements['local-score'].textContent = localScore;
            this.elements['rival-score'].textContent = rivalScore;
        },
        updateButtonStates() {
            const state = AppState.get();
            const started = state.matchEvents.some(e => e.type === 'init_match');
            const finished = state.matchEvents.some(e => e.text.includes('Final'));
            this.elements['btn-toggle-timer'].textContent = started ? "Partido en curso" : "INICIAR PARTIDO";
            this.elements['btn-toggle-timer'].disabled = started ? true : !MatchLogic.checkStartingConditions();
            this.elements['btn-half-time'].disabled = !started || finished || state.currentHalf !== 1;
            this.elements['btn-start-second'].disabled = !started || finished || state.currentHalf !== 2 || state.isMatchRunning;
            this.elements['btn-finish-game'].disabled = !started || finished;
            this.elements.eventButtons.forEach(b => b.disabled = !started || finished || !state.isMatchRunning);
            this.elements['possession-controls'].style.opacity = state.isMatchRunning ? '1' : '0.5';
        },
        renderTimeline() {
            const state = AppState.get();
            this.elements['event-timeline'].innerHTML = '';
            state.matchEvents.slice().reverse().forEach(event => {
                const iconMap = {'goal':'⚽', 'shot':'💥', 'shot-on-goal': '🎯', 'corner': '⛳', 'offside': '🏳️', 'foul':'✋', 'yellow-card':'🟨', 'red-card':'🟥', 'init_match':'▶️', 'control':'⏸️', 'substitution': '🔄'};
                const el = document.createElement('div');
                el.style.marginBottom = '8px';
                el.innerHTML = `<span style="opacity: 0.7;">Min ${event.minute}'</span> - ${iconMap[event.type] || ''} ${event.text}`;
                this.elements['event-timeline'].appendChild(el);
            });
        },
        updateStatsTables() {
            const state = AppState.get();
            const buildTable = (team, players) => {
                const tbody = this.elements[`${team}-stats-table`].querySelector('tbody');
                tbody.innerHTML = '';
                players.forEach(name => {
                    const stats = state.playerStats[team]?.[name];
                    if (!stats) return;
                    const row = tbody.insertRow();
                    row.innerHTML = `<td>${name}</td><td>${stats.goles}</td><td>${stats.asistencias}</td><td>${stats.disparos}</td><td>${stats.disparosAPuerta}</td><td>${stats.faltas}</td><td>${stats.amarillas}</td><td>${stats.rojas}</td><td>${MatchLogic.formatTime(stats.minutosJugados)}</td>`;
                    if (stats.onPitch) row.classList.add('player-on-pitch');
                });
            };
            buildTable('local', state.localPlayers);
            buildTable('rival', state.rivalDorsals);
        },
        updateMatchStats() {
            const state = AppState.get();
            let stats = { 
                local: { shots: 0, sot: 0, yellow: 0, red: 0, corners: state.matchStats.local.corners, offsides: state.matchStats.local.offsides }, 
                rival: { shots: 0, sot: 0, yellow: 0, red: 0, corners: state.matchStats.rival.corners, offsides: state.matchStats.rival.offsides }
            };
            for (const p of Object.values(state.playerStats.local)) { stats.local.shots += p.disparos; stats.local.sot += p.disparosAPuerta; stats.local.yellow += p.amarillas; stats.local.red += p.rojas; }
            for (const p of Object.values(state.playerStats.rival)) { stats.rival.shots += p.disparos; stats.rival.sot += p.disparosAPuerta; stats.rival.yellow += p.amarillas; stats.rival.red += p.rojas; }
            const totalPossession = state.possession.localSeconds + state.possession.rivalSeconds;
            const localPct = totalPossession > 0 ? Math.round((state.possession.localSeconds / totalPossession) * 100) : 50;
            const updateRow = (t, l, r) => { document.getElementById(`stat-local-${t}`).textContent=l; document.getElementById(`stat-rival-${t}`).textContent=r; const total = l+r; document.getElementById(`stat-bar-${t}`).style.width = `${total > 0 ? (l/total)*100 : 50}%`; };
            updateRow('shots', stats.local.shots, stats.rival.shots); updateRow('sot', stats.local.sot, stats.rival.sot);
            updateRow('corners', stats.local.corners, stats.rival.corners); updateRow('offsides', stats.local.offsides, stats.rival.offsides);
            updateRow('yellow', stats.local.yellow, stats.rival.yellow); updateRow('red', stats.local.red, stats.rival.red);
            document.getElementById('stat-local-possession').textContent = `${localPct}%`;
            document.getElementById('stat-rival-possession').textContent = `${100-localPct}%`;
            document.getElementById('stat-bar-possession').style.width = `${localPct}%`;
            this.elements['possession-local'].classList.toggle('active', state.possession.team === 'local');
            this.elements['possession-rival'].classList.toggle('active', state.possession.team === 'rival');
        },
        updateTimerDisplay() {
            const state = AppState.get();
            const mainTimerEl = this.elements['minuto-actual'];
            const addedTimeEl = this.elements['added-time'];

            if (state.currentHalf === 1 && state.matchTimer >= AppConfig.FIRST_HALF_MAX_TIME) {
                mainTimerEl.value = MatchLogic.formatTime(AppConfig.FIRST_HALF_MAX_TIME);
                const addedSeconds = state.matchTimer - AppConfig.FIRST_HALF_MAX_TIME;
                addedTimeEl.textContent = `+${MatchLogic.formatTime(addedSeconds)}`;
                addedTimeEl.classList.remove('hidden');
            } else if (state.currentHalf === 2 && state.matchTimer >= AppConfig.SECOND_HALF_MAX_TIME) {
                mainTimerEl.value = MatchLogic.formatTime(AppConfig.SECOND_HALF_MAX_TIME);
                const addedSeconds = state.matchTimer - AppConfig.SECOND_HALF_MAX_TIME;
                addedTimeEl.textContent = `+${MatchLogic.formatTime(addedSeconds)}`;
                addedTimeEl.classList.remove('hidden');
            } else {
                mainTimerEl.value = MatchLogic.formatTime(state.matchTimer);
                addedTimeEl.classList.add('hidden');
            }
        },
        updateDocumentTitle() {
            const state = AppState.get();
            const time = MatchLogic.formatTime(state.matchTimer);
            const score = `${state.localTeamName} ${this.elements['local-score'].textContent}-${this.elements['rival-score'].textContent} ${state.rivalTeamName}`;
            let prefix = 'Preparación';
            if (state.matchEvents.some(e => e.text.includes('Final'))) prefix = 'FINAL';
            else if (state.matchEvents.some(e => e.text.includes('Descanso')) && !state.isMatchRunning) prefix = 'DESCANSO';
            else if (state.isMatchRunning) prefix = time;
            else if (state.matchEvents.length > 0) prefix = `PAUSA ${time}`;
            document.title = `${prefix} | ${score}`;
        },
        startFormationSelection(team) {
            const state = AppState.get();
            this.elements['formation-modal-title'].innerHTML = `Selecciona formación para <strong>${team === 'local' ? state.localTeamName : state.rivalTeamName}</strong>`;
            this.elements['formation-buttons'].innerHTML = '';
            Object.keys(AppConfig.FORMATIONS).forEach(name => {
                const btn = document.createElement('button'); btn.textContent = name; btn.className = 'btn-primary';
                btn.onclick = () => EventHandler.handleFormationSelect(name, team); 
                this.elements['formation-buttons'].appendChild(btn);
            });
            this.elements['skip-formation'].onclick = () => EventHandler.proceedToNextStep(team);
            this.elements['formation-modal'].classList.add('visible');
        },
    };

    // --- 4. LÓGICA DEL PARTIDO ---
    const MatchLogic = {
        formatTime(s) { const m = Math.floor(s / 60), c = s % 60; return `${m.toString().padStart(2, "0")}:${c.toString().padStart(2, "0")}`; },
        initializeNewMatch() {
            const state = AppState.get();
            state.localTeamName = DOM.elements['local-name-input'].value.trim() || 'Local';
            state.rivalTeamName = DOM.elements['rival-name'].value.trim() || 'Rival';
            
            // Inicializar eliminatedPlayers si no existe
            if (!state.eliminatedPlayers) {
                state.eliminatedPlayers = { local: [], rival: [] };
            }
            
            // Cargar jugadores desde los inputs
            const newLocalPlayers = DOM.elements['local-players'].value.split(',').map(s => s.trim()).filter(Boolean);
            const newRivalDorsals = DOM.elements['rival-dorsals'].value.split(',').map(s => s.trim()).filter(Boolean);
            
            // Filtrar jugadores eliminados
            state.localPlayers = newLocalPlayers.filter(p => !state.eliminatedPlayers.local.includes(p));
            state.rivalDorsals = newRivalDorsals.filter(d => !state.eliminatedPlayers.rival.includes(d));
            
            if (state.localPlayers.length < AppConfig.MAX_PLAYERS_ON_PITCH || state.rivalDorsals.length < AppConfig.MAX_PLAYERS_ON_PITCH) {
                alert(`Se necesitan al menos ${AppConfig.MAX_PLAYERS_ON_PITCH} jugadores por equipo.`);
                return false;
            }
            this.initializeStats();
            return true;
        },
        initializeStats() {
            const state = AppState.get();
            state.playerStats = { local: {}, rival: {} };
            const initialStats = { onPitch: false, goles: 0, asistencias: 0, disparos: 0, disparosAPuerta: 0, faltas: 0, amarillas: 0, rojas: 0, minutosJugados: 0, expulsado: false, haSidoSustituido: false, position: null };
            state.localPlayers.forEach(p => state.playerStats.local[p] = { ...initialStats });
            state.rivalDorsals.forEach(d => state.playerStats.rival[d] = { ...initialStats });
        },
        checkStartingConditions() {
            const state = AppState.get();
            if (state.matchEvents.some(e => e.type === 'init_match')) return true;
            const localReady = Object.values(state.playerStats.local).filter(p => p.onPitch).length === AppConfig.MAX_PLAYERS_ON_PITCH;
            const rivalReady = Object.values(state.playerStats.rival).filter(p => p.onPitch).length === AppConfig.MAX_PLAYERS_ON_PITCH;
            return localReady && rivalReady;
        },
        _createTimerInterval() {
            const state = AppState.get();
            clearInterval(state.timerInterval);
            state.timerInterval = setInterval(() => {
                if (!state.isMatchRunning) {
                    clearInterval(state.timerInterval);
                    state.timerInterval = null;
                    return;
                }
                const elapsedSeconds = Math.floor((Date.now() - state.timerStartTime) / 1000);
                state.matchTimer = state.timerBaseTime + elapsedSeconds;

                const currentMinute = Math.floor(state.matchTimer / 60);
                if (state.isMatchRunning && currentMinute > state.lastMinuteCheck) {
                    state.lastMinuteCheck = currentMinute;
                    this.rebuildAndRecalculateAllState(); 
                } else {
                    DOM.updateTimerDisplay();
                }
                
                DOM.updateDocumentTitle();
            }, 1000);
        },
        startTimer() {
            const state = AppState.get();
            if (state.isMatchRunning) return;
            state.isMatchRunning = true;
            state.timerStartTime = Date.now();
            state.timerBaseTime = state.matchTimer;
            if (state.possession.team === null) this.setPossession('local');
            this._createTimerInterval();
            DOM.updateButtonStates();
            AppState.save();
        },
        stopTimer() {
            const state = AppState.get();
            if (!state.isMatchRunning) return;
            const elapsedSeconds = Math.floor((Date.now() - state.timerStartTime) / 1000);
            state.matchTimer = state.timerBaseTime + elapsedSeconds;
            this.updatePossession(Math.floor((Date.now() - state.possession.startTime) / 1000));
            state.isMatchRunning = false;
            clearInterval(state.timerInterval);
            state.timerInterval = null;
            this.rebuildAndRecalculateAllState();
            DOM.updateButtonStates();
            AppState.save();
        },
        rebuildAndRecalculateAllState() {
            const state = AppState.get();
            if (!state.initialPlayerState) return;

            state.playerStats = JSON.parse(JSON.stringify(state.initialPlayerState));
            for (const team of Object.values(state.playerStats)) {
                for (const player of Object.values(team)) {
                    Object.assign(player, { goles: 0, asistencias: 0, disparos: 0, disparosAPuerta: 0, faltas: 0, amarillas: 0, rojas: 0, expulsado: false, minutosJugados: 0 });
                }
            }
            state.matchStats = { local: { corners: 0, offsides: 0 }, rival: { corners: 0, offsides: 0 } };
            
            let lastTime = 0;
            state.matchEvents.forEach(event => {
                const timeDelta = event.timeInSeconds - lastTime;
                if (timeDelta > 0) this.adjustPlayerMinutes(timeDelta);

                const teamPStats = state.playerStats[event.team];
                
                switch (event.type) {
                    case 'red-card':
                        if (teamPStats?.[event.player]) { teamPStats[event.player].rojas++; teamPStats[event.player].expulsado = true; this.setPlayerOnBench(event.player, event.team, false); }
                        break;
                    case 'yellow-card': 
                        if (teamPStats?.[event.player]) { teamPStats[event.player].amarillas++; if (teamPStats[event.player].amarillas >= 2) { teamPStats[event.player].expulsado = true; this.setPlayerOnBench(event.player, event.team, false); } }
                        break;
                    case 'goal': if(teamPStats?.[event.goleador]){teamPStats[event.goleador].goles++;teamPStats[event.goleador].disparos++;teamPStats[event.goleador].disparosAPuerta++;} if(event.asistente && state.playerStats[event.team]?.[event.asistente])state.playerStats[event.team][event.asistente].asistencias++; break;
                    case 'shot': if(teamPStats?.[event.player]) teamPStats[event.player].disparos++; break;
                    case 'foul': if(teamPStats?.[event.player]) teamPStats[event.player].faltas++; break;
                    case 'corner': if(state.matchStats[event.team]) state.matchStats[event.team].corners++; break;
                    case 'offside': if(state.matchStats[event.team]) state.matchStats[event.team].offsides++; break;
                }
                lastTime = event.timeInSeconds;
            });

            const finalTimeDelta = state.matchTimer - lastTime;
            if (finalTimeDelta > 0) this.adjustPlayerMinutes(finalTimeDelta);
            
            state.lastMinuteCheck = Math.floor(state.matchTimer / 60);

            DOM.updateAll();
        },
        adjustPlayerMinutes(seconds) {
            if (seconds <= 0) return;
            const state = AppState.get();
            Object.values(state.playerStats).forEach(team => {
                Object.values(team).forEach(player => {
                    if (player.onPitch) player.minutosJugados += seconds;
                });
            });
        },
        updatePossession(seconds) {
            const state = AppState.get();
            if (state.possession.team && seconds > 0) {
                state.possession[`${state.possession.team}Seconds`] += seconds;
            }
            state.possession.startTime = Date.now();
            DOM.updateMatchStats();
        },
        setPossession(team) {
            const state = AppState.get();
            if (!state.isMatchRunning || state.possession.team === team) return;
            this.updatePossession(Math.floor((Date.now() - state.possession.startTime) / 1000));
            state.possession.team = team;
            DOM.updateMatchStats();
        },
        addMatchEvent(eventData) {
            const state = AppState.get();
            const event = { id: Date.now(), minute: Math.floor(state.matchTimer / 60), ...eventData }; 
            state.matchEvents.push(event); 
            DOM.renderTimeline(); 
            AppState.save();
        },
        recalculateMatchStateFromEvents() {
            const state = AppState.get();
            const playerInitialStats = { goles:0, asistencias:0, disparos:0, disparosAPuerta: 0, faltas:0, amarillas:0, rojas:0, expulsado:false };
            Object.values(state.playerStats).forEach(team => Object.values(team).forEach(player => {
                const wasSubstituted = player.haSidoSustituido;
                Object.assign(player, playerInitialStats);
                player.haSidoSustituido = wasSubstituted;
            }));
            state.matchStats = { local: {corners: 0, offsides: 0}, rival: {corners: 0, offsides: 0} };
            state.matchEvents.forEach(e => {
                const teamPStats = state.playerStats[e.team], pStats = teamPStats?.[e.player];
                switch(e.type) {
                    case 'goal': if(teamPStats?.[e.goleador]){teamPStats[e.goleador].goles++;teamPStats[e.goleador].disparos++;teamPStats[e.goleador].disparosAPuerta++;} if(e.asistente && teamPStats?.[e.asistente])teamPStats[e.asistente].asistencias++; break;
                    case 'shot-on-goal': if(pStats){pStats.disparosAPuerta++; pStats.disparos++;} break;
                    case 'shot': if(pStats) pStats.disparos++; break;
                    case 'foul': if(pStats) pStats.faltas++; break;
                    case 'yellow-card': if(pStats) pStats.amarillas++; break;
                    case 'red-card': if(pStats) pStats.rojas++; break;
                    case 'corner': if(state.matchStats[e.team]) state.matchStats[e.team].corners++; break;
                    case 'offside': if(state.matchStats[e.team]) state.matchStats[e.team].offsides++; break;
                }
            });
            Object.keys(state.playerStats).forEach(t => Object.keys(state.playerStats[t]).forEach(pName => {
                const p = state.playerStats[t][pName];
                if (p.rojas > 0 || p.amarillas >= 2) {
                    p.expulsado = true;
                    if (p.onPitch) { this.setPlayerOnBench(pName, t, false); }
                }
            }));
            DOM.updateAll();
        },
        setPlayerOnPitch(name, team, pos) {
            const stats = AppState.get().playerStats[team]?.[name];
            if (stats) {
                stats.onPitch = true;
                stats.position = pos;
                stats.haSidoSustituido = false;
            }
        },
        setPlayerOnBench(name, team, isSubstitution = true) {
            const state = AppState.get();
            const stats = state.playerStats[team]?.[name];
            if (!stats) return;
            const wasOnPitch = stats.onPitch;
            stats.onPitch = false;
            stats.position = null;
            if (wasOnPitch && isSubstitution && state.matchEvents.some(e => e.type === 'init_match')) {
                stats.haSidoSustituido = true;
            }
        },
        getMaxPlayersForTeam(team) {
            const redCards = Object.values(AppState.get().playerStats[team]).filter(p => p.expulsado).length;
            return AppConfig.MAX_PLAYERS_ON_PITCH - redCards;
        }
    };

    // --- 5. GESTIÓN DE EVENTOS DEL USUARIO ---
    const EventHandler = {
        addEventListeners() {
            DOM.elements['start-config'].addEventListener('click', () => this.handleStartConfig());
            DOM.elements['btn-home'].addEventListener('click', () => window.location.href = 'index.html');
            DOM.elements.eventButtons.forEach(b => b.addEventListener('click', (e) => this.handleEventButtonClick(e)));
            DOM.elements['btn-half-time'].addEventListener('click', () => this.handleHalfTime(false));
            DOM.elements['btn-start-second'].addEventListener('click', () => this.handleStartSecondHalf());
            DOM.elements['btn-finish-game'].addEventListener('click', () => this.handleFinishGame(false));
            DOM.elements['btn-reset-match'].addEventListener('click', () => this.handleResetMatch());
            DOM.elements['btn-new-match'].addEventListener('click', () => this.handleNewMatch());
            DOM.elements['btn-export-excel'].addEventListener('click', () => this.exportToCsv());
            DOM.elements['btn-repair-state'].addEventListener('click', () => this.handleRepairState());
            DOM.elements['btn-toggle-timer'].addEventListener('click', () => this.handleToggleTimer());
            DOM.elements['possession-local'].addEventListener('click', () => MatchLogic.setPossession('local'));
            DOM.elements['possession-rival'].addEventListener('click', () => MatchLogic.setPossession('rival'));
            window.addEventListener('beforeunload', () => { 
                const state = AppState.get();
                if (state.isMatchRunning) { 
                    state.timerLastUpdated = Date.now();
                    AppState.save(); 
                }
            });
            document.addEventListener('visibilitychange', () => this.handleVisibilityChange());
        },
        handleStartConfig() {
            AppState.init();
            if (MatchLogic.initializeNewMatch()) {
                DOM.showMatchUI();
                DOM.setupBenchesAndPitch();
                DOM.updateAll();
                DOM.startFormationSelection('local');
            }
        },
        handleFormationSelect(formationName, team) {
            const state = AppState.get();
            Object.values(state.playerStats[team]).forEach(p => p.onPitch = false);
            const players = team === 'local' ? state.localPlayers : state.rivalDorsals;
            players.slice(0, AppConfig.MAX_PLAYERS_ON_PITCH).forEach((playerName, i) => {
                let pos = AppConfig.FORMATIONS[formationName][i];
                if (team === 'rival') pos = { x: 100 - pos.x, y: pos.y };
                MatchLogic.setPlayerOnPitch(playerName, team, { left: `${pos.x}%`, top: `${pos.y}%`});
            });
            this.proceedToNextStep(team);
        },
        proceedToNextStep(currentTeam) {
            DOM.updatePlayerChips(); 
            DOM.updateStatsTables();
            DOM.updateButtonStates();
            AppState.save();
            if (currentTeam === 'local') DOM.startFormationSelection('rival');
            else DOM.elements['formation-modal'].classList.remove('visible');
        },
        handleToggleTimer() {
            const state = AppState.get();
            if (!state.matchEvents.some(e => e.type === 'init_match')) {
                MatchLogic.addMatchEvent({ type: 'init_match', text: 'Inicio del partido.' });
                MatchLogic.startTimer();
            }
        },
        handleHalfTime(isAuto = false) {
            MatchLogic.stopTimer();
            const state = AppState.get();
            // No ajustamos el matchTimer aquí, mantenemos el tiempo real incluyendo descuento
            MatchLogic.addMatchEvent({ type: 'control', text: 'Descanso.' });
            state.currentHalf = 2;
            DOM.updateAll();
        },
        handleStartSecondHalf() {
            MatchLogic.addMatchEvent({ type: 'control', text: 'Inicio de la segunda parte.' });
            MatchLogic.startTimer();
        },
        handleFinishGame(isAuto = false) {
            MatchLogic.stopTimer();
            const state = AppState.get();
            if (!isAuto && state.matchTimer < AppConfig.FULL_TIME_SECONDS) {
                const diff = AppConfig.FULL_TIME_SECONDS - state.matchTimer;
                MatchLogic.adjustPlayerMinutes(diff);
            }
            state.matchTimer = AppConfig.FULL_TIME_SECONDS;
            MatchLogic.addMatchEvent({ type: 'control', text: 'Final del partido.' });
            DOM.updateAll();
            DOM.elements['btn-export-excel'].classList.remove('hidden');
            localStorage.removeItem(AppConfig.APP_STATE_KEY);
        },
        handleResetMatch() {
            if (confirm("¿Seguro que quieres reiniciar? Se perderán todas las estadísticas.")) {
                MatchLogic.stopTimer();
                const state = AppState.get();
                const conf = { localTeamName: state.localTeamName, rivalTeamName: state.rivalTeamName, localPlayers: state.localPlayers, rivalDorsals: state.rivalDorsals };
                AppState.init();
                Object.assign(AppState.get(), conf);
                MatchLogic.initializeStats();
                DOM.setupBenchesAndPitch();
                DOM.updateAll();
                DOM.startFormationSelection('local');
                AppState.save();
            }
        },
        handleNewMatch() {
            if(confirm("¿Empezar un partido nuevo?")) {
                try {
                    // Detener todos los timers y procesos activos
                    const state = AppState.get();
                    
                    // Detener el cronómetro si está corriendo
                    if (state.isMatchRunning) {
                        MatchLogic.stopTimer();
                    }
                    
                    // Limpiar cualquier intervalo activo
                    if (state.timerInterval) {
                        clearInterval(state.timerInterval);
                        state.timerInterval = null;
                    }
                    
                    // Limpiar completamente el localStorage
                    localStorage.removeItem(AppConfig.APP_STATE_KEY);
                    
                    // Limpiar cualquier estado en memoria
                    AppState.init();
                    
                    // Forzar recarga completa de la página
                    setTimeout(() => {
                        window.location.href = window.location.href.split('?')[0];
                    }, 100);
                    
                } catch (error) {
                    console.error('Error en handleNewMatch, usando limpieza forzada:', error);
                    // Si hay algún error, usar la limpieza forzada como respaldo
                    localStorage.clear();
                    setTimeout(() => {
                        window.location.reload(true);
                    }, 50);
                }
            }
        },
        handleVisibilityChange() {
            const state = AppState.get();
            if (document.hidden) {
                if (state.isMatchRunning) AppState.save();
                return;
            }
            if (state.isMatchRunning) {
                const elapsedSeconds = Math.floor((Date.now() - state.timerStartTime) / 1000);
                state.matchTimer = state.timerBaseTime + elapsedSeconds;
                MatchLogic.rebuildAndRecalculateAllState();
            }
        },
        handleEventButtonClick(e) {
            const type = e.currentTarget.dataset.event;
            if (type === 'corner' || type === 'offside') this.startTeamEventFlow(type);
            else this.startPlayerEventFlow(type);
        },
        startPlayerEventFlow(type) {
            const state = AppState.get();
            state.eventFlow = { active: true, type, step: 1 };
            document.querySelector('main').classList.add('selecting-mode');
            let prompt = "Selecciona el jugador";
            if (type === 'goal') prompt = "Selecciona al <strong>goleador</strong>";
            else if (type === 'shot' || type === 'shot-on-goal') prompt = "Selecciona al <strong>rematador</strong>";
            else if (type === 'foul') prompt = "Selecciona al <strong>infractor</strong>";
            else if (type === 'yellow-card' || type === 'red-card') prompt = "Selecciona al jugador (campo o banquillo)";
            DOM.elements['event-flow-message'].innerHTML = `${prompt} <small>(clic aquí para cancelar)</small>`;
            DOM.elements['event-flow-message'].classList.remove('hidden');
            DOM.elements['event-flow-message'].onclick = () => this.endEventFlow(true);
        },
        startTeamEventFlow(type) {
            const state = AppState.get();
            state.eventFlow = { active: true, type };
            const typeText = {'corner': 'Córner', 'offside': 'Fuera de Juego'}[type];
            DOM.elements['event-flow-message'].innerHTML = `¿Para qué equipo es el ${typeText}? <button id="team-event-local" class="btn-primary">${state.localTeamName}</button> <button id="team-event-rival" class="btn-danger">${state.rivalTeamName}</button> <small>(clic para cancelar)</small>`;
            DOM.elements['event-flow-message'].classList.remove('hidden');
            document.getElementById('team-event-local').onclick = () => { if(type==='corner')state.matchStats.local.corners++; else state.matchStats.local.offsides++; MatchLogic.addMatchEvent({ type, text: `${typeText} para <strong>${state.localTeamName}</strong>.`, team: 'local' }); this.endEventFlow(); };
            document.getElementById('team-event-rival').onclick = () => { if(type==='corner')state.matchStats.rival.corners++; else state.matchStats.rival.offsides++; MatchLogic.addMatchEvent({ type, text: `${typeText} para <strong>${state.rivalTeamName}</strong>.`, team: 'rival' }); this.endEventFlow(); };
            DOM.elements['event-flow-message'].onclick = (e) => { if(e.target === DOM.elements['event-flow-message']) this.endEventFlow(true); };
        },
        processEventSelection(chip) {
            const state = AppState.get();
            if (!state.eventFlow.active) return;
            const { type, step } = state.eventFlow;
            const { name, team } = chip.dataset;
            const isCardEvent = type === 'yellow-card' || type === 'red-card';
            if (!isCardEvent && !chip.classList.contains('chip-on-pitch')) return;
            if (type === 'goal' && step === 1) {
                state.eventFlow = { ...state.eventFlow, step: 2, goleador: name, team };
                DOM.elements['event-flow-message'].innerHTML = `GOL de <strong>${name}</strong>. Selecciona al <strong>asistente</strong> (o clic en el goleador si no hay).`;
            } else if (type === 'goal' && step === 2) {
                const { goleador, team } = state.eventFlow;
                const asistente = name !== goleador ? name : null;
                MatchLogic.addMatchEvent({ type, text: `GOL de <strong>${goleador}</strong>` + (asistente ? `. Asistencia de <strong>${asistente}</strong>` : '.'), team, goleador, asistente });
                this.endEventFlow();
            } else {
                const eventMap = {'shot':'Disparo','shot-on-goal':'Tiro a Puerta','foul':'Falta','yellow-card':'Tarjeta Amarilla','red-card':'Tarjeta ROJA'};
                MatchLogic.addMatchEvent({ type, text: `${eventMap[type]} de <strong>${name}</strong>.`, team, player: name });
                this.endEventFlow();
            }
        },
        endEventFlow(cancelled = false) {
            document.querySelector('main').classList.remove('selecting-mode');
            DOM.elements['event-flow-message'].classList.add('hidden');
            AppState.get().eventFlow.active = false;
            if (!cancelled) MatchLogic.recalculateMatchStateFromEvents();
        },
        exportToCsv() {
            const state = AppState.get();
            let csv = `${state.localTeamName}\nJugador,G,A,D,TP,F,Y,R,MIN\n`;
            state.localPlayers.forEach(p => { const s = state.playerStats.local[p]; csv += [p, s.goles, s.asistencias, s.disparos, s.disparosAPuerta, s.faltas, s.amarillas, s.rojas, MatchLogic.formatTime(s.minutosJugados)].join(",") + "\n"; });
            csv += `\n${state.rivalTeamName}\nDorsal,G,A,D,TP,F,Y,R,MIN\n`;
            state.rivalDorsals.forEach(d => { const s = state.playerStats.rival[d]; csv += [d, s.goles, s.asistencias, s.disparos, s.disparosAPuerta, s.faltas, s.amarillas, s.rojas, MatchLogic.formatTime(s.minutosJugados)].join(",") + "\n"; });
            const a = document.createElement("a");
            a.href = URL.createObjectURL(new Blob(["\uFEFF"+csv], {type:'text/csv;charset=utf-8;'}));
            a.download = `estadisticas_${state.localTeamName}_vs_${state.rivalTeamName}.csv`; a.click();
        },
    };

    // --- 6. LÓGICA DE DRAG & DROP ---
    const DragAndDrop = {
        draggedElement: null, offsetX: 0, offsetY: 0,
        startX: 0, startY: 0, isDragging: false,
        _boundMove: null, _boundEnd: null,
        
        // Función auxiliar para limpiar el estado de arrastrar
        clearDragState() {
            if (this.draggedElement) {
                this.draggedElement.classList.remove('dragging');
                this.draggedElement = null;
                this.isDragging = false;
                
                // Remover event listeners de arrastrar
                document.removeEventListener('pointermove', this._boundMove);
                document.removeEventListener('pointerup', this._boundEnd);
            }
        },

        start(e) {
            const el = e.currentTarget;
            const stats = AppState.get().playerStats[el.dataset.team]?.[el.dataset.name];
            if (!el || (stats && (stats.expulsado || stats.haSidoSustituido))) return;
            e.preventDefault();
            this.draggedElement = el;
            this.startX = e.clientX;
            this.startY = e.clientY;
            this._boundMove = this.move.bind(this);
            this._boundEnd = this.end.bind(this);
            document.addEventListener('pointermove', this._boundMove);
            document.addEventListener('pointerup', this._boundEnd);
        },
        move(e) {
            if (!this.draggedElement) return;
            e.preventDefault();
            if (!this.isDragging) {
                const dx = e.clientX - this.startX;
                const dy = e.clientY - this.startY;
                if (Math.sqrt(dx * dx + dy * dy) > 5) {
                    this.isDragging = true;
                    const rect = this.draggedElement.getBoundingClientRect();
                    this.offsetX = e.clientX - rect.left;
                    this.offsetY = e.clientY - rect.top;
                    this.draggedElement.classList.add('dragging');
                    document.body.appendChild(this.draggedElement);
                }
            }
            if (this.isDragging) {
                const x = e.clientX - this.offsetX;
                const y = e.clientY - this.offsetY;
                this.draggedElement.style.left = `${x}px`;
                this.draggedElement.style.top = `${y}px`;
            }
        },
        end(e) {
            document.removeEventListener('pointermove', this._boundMove);
            document.removeEventListener('pointerup', this._boundEnd);
            if (!this.draggedElement) return;
            if (this.isDragging) {
                this.draggedElement.classList.remove('dragging');
                this.draggedElement.style.display = 'none';
                const dropTarget = document.elementFromPoint(e.clientX, e.clientY);
                this.draggedElement.style.display = '';
                this.executeDrop(dropTarget, e.clientX, e.clientY);
            }
            this.draggedElement = null;
            this.isDragging = false;
            DOM.updatePlayerChips(); 
            DOM.updateStatsTables();
            DOM.updateButtonStates();
            AppState.save();
        },
        executeDrop(target, clientX, clientY) {
            const dragged = this.draggedElement;
            const stats = AppState.get().playerStats[dragged.dataset.team][dragged.dataset.name];
            const targetChip = target?.closest('.player-chip');
            const targetZone = target?.closest('#futsal-pitch, .bench');
            
            if (targetChip && targetChip !== dragged && dragged.dataset.team === targetChip.dataset.team) {
                this.handlePlayerSwap(dragged, targetChip);
            } else if (targetZone?.id === 'futsal-pitch') {
                const maxPlayers = MatchLogic.getMaxPlayersForTeam(dragged.dataset.team);
                const teamPlayersOnPitch = Object.values(AppState.get().playerStats[dragged.dataset.team]).filter(p => p.onPitch).length;
                if (teamPlayersOnPitch >= maxPlayers && !stats.onPitch) {
                    alert(`Este equipo solo puede tener ${maxPlayers} jugadores en el campo.`);
                } else {
                    const rect = targetZone.getBoundingClientRect();
                    const xPercent = 100 * (clientX - rect.left) / rect.width;
                    if ((dragged.dataset.team === 'local' && xPercent > 50) || (dragged.dataset.team === 'rival' && xPercent < 50)) return;
                    const pos = { left: `${xPercent}%`, top: `${100 * (clientY - rect.top) / rect.height}%` };
                    MatchLogic.setPlayerOnPitch(dragged.dataset.name, dragged.dataset.team, pos);
                }
            } else if (targetZone?.classList.contains('bench')) {
                if (targetZone.id === `${dragged.dataset.team}-bench`) {
                    MatchLogic.setPlayerOnBench(dragged.dataset.name, dragged.dataset.team);
                }
            }
        },
        handlePlayerSwap(playerIn, playerOut) {
            const state = AppState.get();
            const statsIn = state.playerStats[playerIn.dataset.team][playerIn.dataset.name];
            const statsOut = state.playerStats[playerOut.dataset.team][playerOut.dataset.name];

            if (statsIn.onPitch && statsOut.onPitch) {
                const posIn = statsIn.position;
                statsIn.position = statsOut.position;
                statsOut.position = posIn;
            } else if (statsIn.onPitch !== statsOut.onPitch) {
                const onPitchPlayerEl = statsIn.onPitch ? playerIn : playerOut;
                const onBenchPlayerEl = statsIn.onPitch ? playerOut : playerIn;
                const onPitchPlayerName = onPitchPlayerEl.dataset.name;
                const onBenchPlayerName = onBenchPlayerEl.dataset.name;
                const team = onPitchPlayerEl.dataset.team;
                
                const position = state.playerStats[team][onPitchPlayerName].position;

                if (state.matchEvents.some(e => e.type === 'init_match')) {
                     MatchLogic.addMatchEvent({ 
                         type: 'substitution', 
                         text: `Sustitución: Entra <strong>${onBenchPlayerName}</strong>, sale <strong>${onPitchPlayerName}</strong>.`, 
                         team: team
                     });
                }
                
                MatchLogic.setPlayerOnBench(onPitchPlayerName, team);
                MatchLogic.setPlayerOnPitch(onBenchPlayerName, team, position);
            }
        }
    };

    // --- 7. INICIALIZACIÓN DE LA APLICACIÓN ---
    document.addEventListener('DOMContentLoaded', () => {
        DOM.cacheElements();
        EventHandler.addEventListeners();

        if (AppState.load()) {
            DOM.showMatchUI();
            DOM.setupBenchesAndPitch();
            const state = AppState.get();
            
            if (state.isMatchRunning) {
                const elapsedSinceSave = Math.floor((Date.now() - state.timerStartTime) / 1000);
                state.matchTimer = state.timerBaseTime + elapsedSinceSave;
                MatchLogic._createTimerInterval();
            }

            if (state.initialPlayerState) {
                MatchLogic.rebuildAndRecalculateAllState();
            } else {
                DOM.updateAll();
            }
        } else {
            AppState.init();
        }
    });
</script>
</body>
</html>