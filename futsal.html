<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Futsal Táctico Interactivo (Versión Final)</title>
    
    <style>
        :root {
            --color-monochrome: #1c1c1c; 
            --color-text: #f0f0f0; 
            --color-highlight: #4a90e2; 
            --color-success: #7ed321; 
            --color-warning: #f5a623;
            --color-danger: #d0021b; 
            --color-background-secondary: #2c2c2c;
            --color-pitch: #c2a185;
        }
        html, body {
            width: 100%; height: 100%; margin: 0; padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: var(--color-monochrome); color: var(--color-text);
            overscroll-behavior: none;
            -webkit-tap-highlight-color: transparent;
        }
        main { padding: 10px; max-width: 900px; margin: 0 auto; }
        section { background-color: var(--color-background-secondary); padding: 15px; border-radius: 10px; margin-bottom: 15px; }
        
        #app-header { display: none; text-align: center; margin-bottom: 15px; }
        
        #marcador {
            font-size: 1.8em; font-weight: bold; color: var(--color-success);
            display: flex; align-items: center; justify-content: space-between;
            gap: 10px; flex-wrap: nowrap;
        }
        .team-info { flex: 1; display: flex; align-items: center; gap: 10px; }
        .team-info.local { justify-content: flex-end; }
        .team-info.rival { justify-content: flex-start; }
        .score-display { flex-shrink: 0; }
        .foul-counter {
            font-size: 0.7em; background-color: #333; color: var(--color-text);
            width: 28px; height: 28px; border-radius: 50%;
            display: inline-flex; align-items: center; justify-content: center;
            border: 2px solid #555; font-weight: bold;
        }
        .foul-warning { background-color: var(--color-danger); border-color: white; }
        .btn-add-foul {
            background: none; border: 1px solid var(--color-text);
            color: var(--color-text); border-radius: 50%; width: 28px; height: 28px;
            padding: 0; font-size: 1.4em; min-width: 28px;
            display: inline-flex; align-items: center; justify-content: center; line-height: 1;
        }

        #tiempo { display: flex; align-items: center; justify-content: center; margin-top: 15px; gap: 10px; }
        #minuto-actual { 
            font-family: 'Courier New', Courier, monospace;
            font-size: 1.3em; font-weight: bold; background: #333; border: 1px solid #555; 
            padding: 5px 10px; border-radius: 4px; width: 80px; text-align: center;
            transition: all 0.2s;
        }
        #minuto-actual.editable {
            cursor: pointer;
            border-color: var(--color-highlight);
            box-shadow: 0 0 10px rgba(74, 144, 226, 0.5);
        }

        button { padding: 12px; border: none; border-radius: 8px; font-size: 1em; cursor: pointer; transition: background-color 0.2s; }
        button:disabled { background-color: #555 !important; color: #999; cursor: not-allowed; }
        .btn-primary { background-color: var(--color-highlight); color: var(--color-monochrome); }
        .btn-secondary { background-color: var(--color-background-secondary); color: var(--color-text); border: 1px solid var(--color-text); }
        .btn-danger { background-color: var(--color-danger); color: var(--color-text); }
        .btn-event { background-color: var(--color-background-secondary); color: var(--color-highlight); border: 2px solid var(--color-highlight); font-weight: bold; }

        #game-controls { padding-top: 5px; }
        .control-group, .event-group { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 15px; }
        .event-group button { flex: 1 1 calc(25% - 10px); }
        .control-group button { flex: 1 1 auto; }

        label { display: block; margin-top: 10px; margin-bottom: 5px; font-weight: bold; }
        input[type="text"], input[type="number"], textarea, select { width: 100%; padding: 10px; margin-bottom: 10px; border: 1px solid #444; background-color: #333; color: var(--color-text); border-radius: 5px; box-sizing: border-box; }

        #pitch-section { position: relative; }
        
        #event-flow-message {
            position: absolute; 
            top: 10px; 
            left: 50%;
            width: 90%;
            max-width: 350px;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 12px 22px;
            border-radius: 25px;
            z-index: 1001;
            font-size: 1em;
            border: 1px solid var(--color-highlight);
            box-shadow: 0 4px 8px rgba(0,0,0,0.5);
            text-align: center;
            cursor: pointer;
        }
        
        .selecting-mode { cursor: crosshair !important; }

        #futsal-pitch { position: relative; width: 100%; aspect-ratio: 2 / 1; touch-action: none; }
        #futsal-pitch-svg { width: 100%; height: 100%; }
        #bench-container { display: flex; margin-top: 10px; gap: 10px; }
        .bench {
            width: 50%; min-height: 90px; border: 2px dashed #444;
            border-radius: 5px; padding: 8px; display: flex; flex-wrap: wrap;
            gap: 8px; align-content: flex-start; justify-content: center;
            touch-action: manipulation;
        }

        .player-chip {
            position: relative;
            width: 45px; height: 45px; border-radius: 50%; color: white;
            display: flex; align-items: center; justify-content: center;
            font-weight: bold; font-size: 14px; cursor: grab; user-select: none;
            border: 2px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.5);
            transition: opacity 0.2s, transform 0.2s, border 0.2s, filter 0.3s;
            touch-action: none;
        }
        .yellow-card-icon {
            position: absolute;
            top: -2px; right: -2px;
            font-size: 12px;
            background-color: #f5a623;
            width: 15px; height: 15px;
            border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            border: 1px solid white;
            line-height: 1;
        }
        .chip-local { background-color: var(--color-highlight); }
        .chip-rival { background-color: var(--color-danger); }
        .chip-on-pitch { position: absolute; z-index: 10; }
        .dragging { opacity: 0.7; cursor: grabbing; box-shadow: 0 5px 15px rgba(0,0,0,0.8); transform: scale(1.1); z-index: 1000; }
        .expulsado { filter: grayscale(100%); cursor: not-allowed !important; opacity: 0.6; }

        table { 
            width: 100%; border-collapse: collapse; margin-top: 10px; 
            font-size: 0.9em; table-layout: fixed;
        }
        th, td { 
            padding: 8px; text-align: center; border-bottom: 1px solid #444; 
            overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
        }
        th:first-child, td:first-child { 
            width: 35%; text-align: left;
        }
        .player-on-pitch { background-color: rgba(74, 144, 226, 0.2); font-weight: bold; }
        
        .stat-highlight {
            background-color: var(--color-highlight);
            color: var(--color-monochrome);
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        #timeline-section { border-left: 3px solid var(--color-highlight); }
        #event-timeline { max-height: 300px; overflow-y: auto; padding-left: 15px;}
        .timeline-event { 
            margin-bottom: 10px; font-size: 0.9em; 
            display: flex; align-items: center; justify-content: space-between; 
            cursor: pointer; padding: 5px; border-radius: 5px;
            transition: background-color 0.2s;
        }
        .timeline-event:hover { background-color: #3f3f3f; }
        .timeline-event-main { display: flex; align-items: center; }
        .timeline-event .event-icon { margin-right: 10px; font-size: 1.2em; }
        .timeline-event strong { color: var(--color-success); }
        
        #context-menu {
            position: fixed;
            z-index: 10000;
            background-color: #3e3e3e;
            border: 1px solid #555;
            border-radius: 8px;
            padding: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        #context-menu button {
            display: block;
            width: 100%;
            background: none;
            border: none;
            color: var(--color-text);
            padding: 10px 15px;
            text-align: left;
            border-radius: 5px;
        }
        #context-menu button:hover {
            background-color: var(--color-highlight);
            color: var(--color-monochrome);
        }

        .modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 10001;
            background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center;
        }
        .modal-content {
            background: var(--color-background-secondary); padding: 20px;
            border-radius: 10px; width: 90%; max-width: 400px;
            max-height: 90vh;
            overflow-y: auto;
        }
        .modal-content .close-btn { float: right; font-size: 1.5em; cursor: pointer; }
        
        .time-editor-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
        }
        .time-editor-unit {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .time-editor-buttons {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .time-editor-buttons button {
            font-size: 1.2em;
            padding: 0;
            width: 40px;
            height: 35px;
            line-height: 35px;
            background-color: var(--color-background-secondary);
            border: 1px solid var(--color-text);
            color: var(--color-text);
            border-radius: 4px;
        }
        .time-editor-unit input {
            width: 80px;
            height: 75px;
            font-size: 3em;
            font-weight: bold;
            text-align: center;
            border: 2px solid #555;
            background-color: #333;
            color: var(--color-text);
            -moz-appearance: textfield;
            appearance: textfield;
        }
        .time-editor-unit input::-webkit-outer-spin-button,
        .time-editor-unit input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .time-editor-separator {
            font-size: 3em;
            font-weight: bold;
            padding-bottom: 5px;
        }

        .hidden { display: none !important; }
        
        #tab-blocker {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 20000;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            text-align: center; padding: 20px; box-sizing: border-box;
        }
        #tab-blocker h2 { color: var(--color-warning); }
        
        @media (max-width: 768px) {
            main { padding: 5px; }
            section { padding: 10px; }
            h2 { font-size: 1.2em; }
            #bench-container { flex-direction: column; }
            .bench { width: auto; min-height: 60px; }
            .player-chip { width: 38px; height: 38px; font-size: 11px; }
            .control-group button, .event-group button { padding: 10px; font-size: 0.9em; }
            table { font-size: 0.8em; }
            th, td { padding: 5px 3px; }
            #marcador { font-size: 1.4em; }
            .foul-counter, .btn-add-foul { width: 24px; height: 24px; min-width: 24px; }
            
            th:first-child, td:first-child { 
                width: 30% !important;
                text-align: left;
            }
            .time-editor-display { font-size: 2em; width: 50px; }
            .time-editor-btn { width: 40px; height: 40px; font-size: 1.5em; }
        }
    </style>
</head>
<body>
    <div id="tab-blocker" class="hidden">
        <h2>Pestaña Bloqueada</h2>
        <p>La aplicación ya está abierta en otra pestaña.</p>
        <p>Para evitar conflictos de datos, solo puedes tener una sesión activa. Por favor, cierra esta pestaña o la otra.</p>
    </div>

    <main>
        <section id="config-section">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2 style="margin: 0;">Configuración del Partido</h2>
                <button id="btn-home" class="btn-secondary" style="display: flex; align-items: center; gap: 8px; padding: 10px 15px;">
                    <span style="font-size: 1.2em;">🏠</span>
                    <span>Menú Principal</span>
                </button>
            </div>
            <label for="local-name-input">Nombre Equipo Local:</label>
            <input type="text" id="local-name-input" value="Athletic Club Móstoles">
            <label for="rival-name">Nombre Rival:</label>
            <input type="text" id="rival-name">
            <label for="local-players">Jugadores Locales (separados por coma):</label>
            <textarea id="local-players" rows="3"></textarea>
            <label for="rival-dorsals">Dorsales Rivales (separados por coma):</label>
            <input type="text" id="rival-dorsals">
            <button id="start-config" class="btn-primary">Guardar y Preparar Pizarra</button>
        </section>

        <header id="app-header">
            <h1>Gestión de Partido</h1>
            <div id="marcador">
                <div class="team-info local">
                    <span id="local-name">Local</span>
                    <button id="local-add-foul" class="btn-add-foul">+</button>
                    <div id="local-foul-counter" class="foul-counter">0</div>
                </div>
                <div class="score-display">
                    <span id="local-score">0</span> - <span id="rival-score">0</span>
                </div>
                <div class="team-info rival">
                    <div id="rival-foul-counter" class="foul-counter">0</div>
                    <button id="rival-add-foul" class="btn-add-foul">+</button>
                    <span id="rival-name-display">Rival</span>
                </div>
            </div>
            <div id="tiempo">
                <button id="btn-toggle-timer" class="btn-primary" disabled>Coloca los jugadores</button>
                <div id="minuto-actual">20:00</div>
            </div>
        </header>

        <section id="pitch-section" class="hidden">
            <h2>Pizarra Táctica</h2>
            <div id="event-flow-message" class="hidden"></div>
            <div id="futsal-pitch">
                <svg id="futsal-pitch-svg" viewBox="0 0 800 400" preserveAspectRatio="xMidYMid meet">
                    <rect width="800" height="400" fill="var(--color-pitch)" stroke="white" stroke-width="3"/>
                    <line x1="400" y1="0" x2="400" y2="400" stroke="white" stroke-width="3"/>
                    <circle cx="400" cy="200" r="60" stroke="white" stroke-width="3" fill="none"/>
                    <path d="M 0 100 A 120 120 0 0 1 0 300" stroke="white" stroke-width="3" fill="none"/>
                    <path d="M 800 100 A 120 120 0 0 0 800 300" stroke="white" stroke-width="3" fill="none"/>
                </svg>
            </div>
            <div id="bench-container">
                <div id="local-bench" class="bench"></div>
                <div id="rival-bench" class="bench"></div>
            </div>
        </section>

        <section id="game-controls" class="hidden">
            <div class="control-group">
                <button id="btn-half-time" class="btn-secondary" disabled>Descanso</button>
                <button id="btn-start-second" class="btn-secondary" disabled>Inicio 2ª</button>
                <button id="btn-finish-game" class="btn-danger" disabled>Finalizar</button>
            </div>
            <div class="event-group">
                <button class="btn-event" data-event="goal">GOL ⚽</button>
                <button class="btn-event" data-event="yellow-card">AMARILLA 🟨</button>
                <button class="btn-event" data-event="red-card">ROJA 🟥</button>
                <button class="btn-event" data-event="foul">FALTA ✋</button>
            </div>
        </section>
        
        <section id="timeline-section" class="hidden">
            <h2>Cronología del Partido</h2>
            <div id="event-timeline"></div>
        </section>
        
        <section id="stats-section" class="hidden">
            <h2>Estadísticas</h2>
            <h3 id="local-stats-title">Equipo Local</h3>
            <table id="local-stats-table">
                <thead>
                    <tr><th>Jugador</th><th>G</th><th>A</th><th>🟨</th><th>🟥</th><th>F</th><th>⏱️</th></tr>
                </thead>
                <tbody></tbody>
            </table>
            <h3 id="rival-stats-title">Rival</h3>
            <table id="rival-stats-table">
                <thead>
                    <tr><th>Dorsal</th><th>G</th><th>A</th><th>🟨</th><th>🟥</th><th>F</th><th>⏱️</th></tr>
                </thead>
                <tbody></tbody>
            </table>
            <div class="control-group" style="margin-top: 20px;">
                <button id="btn-reset-match" class="btn-secondary">Reiniciar</button>
                <button id="btn-new-match" class="btn-secondary">Nuevo Partido</button>
            </div>
            <button id="btn-export-excel" class="btn-primary hidden" style="margin-top: 20px;">Exportar a Excel</button>
        </section>
        
        <div id="edit-event-modal" class="modal hidden">
            <div class="modal-content">
                <span class="close-btn">&times;</span>
                <h3 id="edit-modal-title">Editar Evento</h3>
                <div id="edit-event-time-editor"></div>
                <div id="edit-event-dynamic-fields"></div>
                <button id="save-event-changes-btn" class="btn-primary" style="width:100%; margin-top: 20px;">Guardar Cambios</button>
            </div>
        </div>

        <div id="edit-time-modal" class="modal hidden">
            <div class="modal-content">
                <span class="close-btn">&times;</span>
                <h3>Ajustar Tiempo (Cuenta atrás de la mitad actual)</h3>
                <div class="time-editor-container">
                    <div class="time-editor-unit">
                        <div class="time-editor-buttons">
                            <button id="time-editor-min-plus">+</button>
                            <button id="time-editor-min-minus">-</button>
                        </div>
                        <input type="number" id="time-editor-min" min="0" max="25">
                    </div>
                    <span class="time-editor-separator">:</span>
                    <div class="time-editor-unit">
                        <input type="number" id="time-editor-sec" min="0" max="59">
                        <div class="time-editor-buttons">
                            <button id="time-editor-sec-plus">+</button>
                            <button id="time-editor-sec-minus">-</button>
                        </div>
                    </div>
                </div>
                <div style="text-align: center; display:flex; gap: 10px; justify-content: center;">
                    <button id="save-time-btn" class="btn-primary">Guardar</button>
                    <button id="cancel-time-btn" class="btn-secondary">Cancelar</button>
                </div>
            </div>
        </div>
        
        <div id="context-menu" class="hidden">
            <button id="ctx-menu-edit">✏️ Editar</button>
            <button id="ctx-menu-delete">🗑️ Borrar</button>
        </div>
    </main>

<script>
    // --- BLOQUE DE CADUCIDAD ---
    const fechaDeCaducidad = new Date('2026-10-07'); 
    if (new Date() > fechaDeCaducidad) {
        document.body.innerHTML = `<div style="text-align: center; padding: 50px; font-family: sans-serif; color: #f0f0f0;"><h1>Versión de prueba expirada</h1><p>Por favor, contacta con el creador para más información.</p></div>`;
        throw new Error("La versión de prueba ha expirado.");
    }
    
    // --- GESTOR DE PESTAÑAS ---
    const TAB_ID = Date.now().toString();
    const PRIMARY_TAB_KEY = 'futsal_primary_tab';
    const HEARTBEAT_KEY = 'futsal_heartbeat';
    let isPrimaryTab = false;
    let heartbeatInterval = null;

    function manageTabs() {
        const lastHeartbeat = parseInt(localStorage.getItem(HEARTBEAT_KEY) || '0', 10);
        
        if (isNaN(lastHeartbeat) || Date.now() - lastHeartbeat > 5000) {
            becomePrimaryTab();
        } else {
            document.getElementById('tab-blocker').classList.remove('hidden');
        }

        window.addEventListener('storage', (e) => {
            if (e.key === PRIMARY_TAB_KEY && e.newValue === null) {
                alert('La pestaña principal se ha cerrado. Recarga para tomar el control.');
                document.getElementById('tab-blocker').classList.add('hidden');
            }
        });
    }
    
    function becomePrimaryTab() {
        isPrimaryTab = true;
        localStorage.setItem(PRIMARY_TAB_KEY, TAB_ID);
        
        heartbeatInterval = setInterval(() => {
            localStorage.setItem(HEARTBEAT_KEY, Date.now().toString());
        }, 3000);

        window.addEventListener('beforeunload', () => {
            if (isPrimaryTab) {
                clearInterval(heartbeatInterval);
                localStorage.removeItem(PRIMARY_TAB_KEY);
                localStorage.removeItem(HEARTBEAT_KEY);
            }
        });

        initializeApp();
    }

    // --- ESTADO GLOBAL DE LA APLICACIÓN ---
    let gameState = {};
    let isNavigatingIntentionally = false;
    let timerInterval = null; 

    function getInitialGameState() {
        return {
            localTeamName: 'Local', rivalTeamName: 'Rival', localPlayers: [], rivalDorsals: [],
            playerStats: { local: {}, rival: {} },
            faltas: { local: 0, rival: 0 },
            matchTimer: 0,
            currentHalf: 1, 
            isMatchFinished: false,
            matchEvents: [],
            penalties: [],
            eventFlowState: { active: false, type: null, step: 0, payload: {} },
            draggedElement: null,
            initialLineup: { local: [], rival: [] },
            eliminatedPlayers: { local: [], rival: [] }
        };
    }

    // --- REFERENCIAS AL DOM ---
    const minutoActualDisplay = document.getElementById('minuto-actual');
    const pitch = document.getElementById('futsal-pitch');
    const localBench = document.getElementById('local-bench');
    const rivalBench = document.getElementById('rival-bench');
    const timelineContainer = document.getElementById('event-timeline');
    const eventFlowMessage = document.getElementById('event-flow-message');
    const mainContainer = document.querySelector('main');
    const editEventModal = document.getElementById('edit-event-modal');
    const editTimeModal = document.getElementById('edit-time-modal');
    
    // --- LÓGICA DE INICIALIZACIÓN ---
    document.addEventListener('DOMContentLoaded', manageTabs);
    
    function initializeApp() {
        assignAllEventListeners();
        if (!loadStateAndSyncTimer()) {
            gameState = getInitialGameState();
            setupInitialConfig();
        }
        document.addEventListener('visibilitychange', handleVisibilityChange);
    }

    function assignAllEventListeners() {
        document.getElementById('start-config').addEventListener('click', handleStartConfig);
        document.getElementById('btn-home').addEventListener('click', () => window.location.href = 'index.html');
        document.getElementById('btn-toggle-timer').addEventListener('click', handleToggleTimer);
        document.getElementById('btn-half-time').addEventListener('click', handleHalfTime);
        document.getElementById('btn-start-second').addEventListener('click', handleStartSecondHalf);
        document.getElementById('btn-finish-game').addEventListener('click', handleFinishGame);
        document.getElementById('btn-reset-match').addEventListener('click', handleResetMatch);
        document.getElementById('btn-new-match').addEventListener('click', handleNewMatch);
        document.getElementById('btn-export-excel').addEventListener('click', exportToCsv);
        document.getElementById('local-add-foul').addEventListener('click', () => handleQuickFoul('local'));
        document.getElementById('rival-add-foul').addEventListener('click', () => handleQuickFoul('rival'));
        document.querySelectorAll('.btn-event').forEach(b => b.addEventListener('click', handleEventButtonClick));
        minutoActualDisplay.addEventListener('click', openEditTimeModal);
        
        editTimeModal.querySelector('.close-btn').addEventListener('click', () => editTimeModal.classList.add('hidden'));
        document.getElementById('save-time-btn').addEventListener('click', handleSaveTimeEdit);
        document.getElementById('cancel-time-btn').addEventListener('click', () => editTimeModal.classList.add('hidden'));
        
        // Event listeners para los botones de tiempo
        document.getElementById('time-editor-min-plus').addEventListener('click', () => adjustTimeValue('min', 1));
        document.getElementById('time-editor-min-minus').addEventListener('click', () => adjustTimeValue('min', -1));
        document.getElementById('time-editor-sec-plus').addEventListener('click', () => adjustTimeValue('sec', 1));
        document.getElementById('time-editor-sec-minus').addEventListener('click', () => adjustTimeValue('sec', -1));
        
        editEventModal.querySelector('.close-btn').addEventListener('click', () => editEventModal.classList.add('hidden'));
        document.getElementById('save-event-changes-btn').addEventListener('click', handleSaveEventEdit);

        eventFlowMessage.addEventListener('click', () => endEventFlow(true));
        document.addEventListener('click', (e) => {
            const contextMenu = document.getElementById('context-menu');
            if (contextMenu && !contextMenu.contains(e.target)) {
                 contextMenu.classList.add('hidden');
            }
        });
        window.addEventListener('beforeunload', () => {
            if (isPrimaryTab && !isNavigatingIntentionally && gameState.matchEvents && gameState.matchEvents.length > 0) {
                 saveState();
            }
        });
    }

    function setupInitialConfig() {
        const rivalDorsals = Array.from({length: 12}, () => Math.floor(Math.random() * 99) + 1);
        
        document.getElementById('local-name-input').value = "Athletic Club Móstoles";
        document.getElementById('rival-name').value = "Equipo Rival";
        document.getElementById('local-players').value = "Richi, Fran, Sarco, Iker, Miguel, Dani, Aseraf, Pablo, DiegoB, DiegoM, Rodri, Gabal, Nivo, Bermu, Sergio";
        document.getElementById('rival-dorsals').value = [...new Set(rivalDorsals)].join(', ');
    }
    
    // --- LÓGICA DEL CRONÓMETRO PERSISTENTE ---
    
    const HALF_TIME_SECONDS = 20 * 60;
    const PENALTY_DURATION_SECONDS = 2 * 60;
    const TIMER_STATE_KEY = 'futsalTimerState';

    function startTimer() {
        if (timerInterval || gameState.isMatchFinished) return;
    
        const timerState = {
            isMatchRunning: true,
            timerBaseTime: gameState.matchTimer,
            timerStartTime: Date.now()
        };
        localStorage.setItem(TIMER_STATE_KEY, JSON.stringify(timerState));

        timerInterval = setInterval(() => {
            const elapsed = (Date.now() - timerState.timerStartTime) / 1000;
            gameState.matchTimer = timerState.timerBaseTime + elapsed;
            
            updateTimerUI();
            recalculateAllPlayerMinutes();
            updateStatsTables();
            checkPenalties();
            
            if (gameState.currentHalf === 1 && gameState.matchTimer >= HALF_TIME_SECONDS) {
                handleHalfTime();
            } else if (gameState.currentHalf === 2 && gameState.matchTimer >= 2 * HALF_TIME_SECONDS) {
                handleFinishGame();
            }
        }, 1000); 
        
        updateButtonStates();
    }

    function pauseTimer() {
        if (!timerInterval) return;

        clearInterval(timerInterval);
        timerInterval = null;

        const timerState = JSON.parse(localStorage.getItem(TIMER_STATE_KEY) || '{}');
        const elapsed = (Date.now() - (timerState.timerStartTime || Date.now())) / 1000;
        gameState.matchTimer = (timerState.timerBaseTime || gameState.matchTimer) + elapsed;
        
        localStorage.removeItem(TIMER_STATE_KEY);
        
        updateTimerUI();
        updateButtonStates();
        rebuildAndRecalculateAllStats();
        saveState();
    }

    function handleToggleTimer() {
        if (gameState.matchEvents.length === 0) {
            const localOnPitch = Object.values(gameState.playerStats.local).filter(p => p.onPitch).length;
            const rivalOnPitch = Object.values(gameState.playerStats.rival).filter(p => p.onPitch).length;
            if (localOnPitch !== 5 || rivalOnPitch !== 5) {
                return alert("Debes colocar 5 jugadores de cada equipo en el campo para iniciar el partido.");
            }
            gameState.initialLineup.local = Object.keys(gameState.playerStats.local).filter(p => gameState.playerStats.local[p].onPitch);
            gameState.initialLineup.rival = Object.keys(gameState.playerStats.rival).filter(p => gameState.playerStats.rival[p].onPitch);
            addMatchEvent({ type: 'init_match', text: 'Inicio del partido.' });
        }
        
        const isRunning = !!timerInterval;
        isRunning ? pauseTimer() : startTimer();
    };

    function updateTimerUI() {
        const displayTime = formatTime(gameState.matchTimer);
        minutoActualDisplay.textContent = displayTime;
        updateDocumentTitle(displayTime);
    }
    
    function formatTime(totalSeconds) {
        totalSeconds = Math.floor(totalSeconds);
        const halfProgress = (gameState.currentHalf === 1) ? totalSeconds : totalSeconds - HALF_TIME_SECONDS;
        const remainingSecondsInHalf = HALF_TIME_SECONDS - halfProgress;
        const displaySeconds = Math.max(0, remainingSecondsInHalf);
        const mins = Math.floor(displaySeconds / 60);
        const secs = Math.floor(displaySeconds % 60);
        return `${String(mins).padStart(2,'0')}:${String(secs).padStart(2,'0')}`;
    }

    function formatTimeAscending(seconds) {
        const mins = Math.ceil(seconds / 60);
        return `${mins}'`;
    }
    
    function handleVisibilityChange() {
        if (!document.hidden && isPrimaryTab) {
            loadStateAndSyncTimer();
        }
    }

    // --- LÓGICA DE PARTIDO Y ESTADO ---
    
    const APP_STATE_KEY = 'futsalTacticoState';

    function saveState() {
        if (!isPrimaryTab) return;
        const stateToSave = { ...gameState };
        localStorage.setItem(APP_STATE_KEY, JSON.stringify(stateToSave));
    }

    function loadStateAndSyncTimer() {
        const savedStateJSON = localStorage.getItem(APP_STATE_KEY);
        if (!savedStateJSON) return false;

        gameState = { ...getInitialGameState(), ...JSON.parse(savedStateJSON) };
        
        // Asegurar que eliminatedPlayers existe
        if (!gameState.eliminatedPlayers) {
            gameState.eliminatedPlayers = { local: [], rival: [] };
        }
        
        const timerState = JSON.parse(localStorage.getItem(TIMER_STATE_KEY) || '{}');
        if (timerState.isMatchRunning) {
            const elapsedWhileAway = (Date.now() - timerState.timerStartTime) / 1000;
            const newTotalTime = timerState.timerBaseTime + elapsedWhileAway;
            gameState.matchTimer = newTotalTime;
            startTimer();
        }

        rebuildUIFromState();
        
        if (gameState.isMatchFinished) {
            handleFinishGame(true);
        }

        return true;
    }

    function handleStartConfig() {
        gameState = getInitialGameState();
        gameState.localTeamName = document.getElementById('local-name-input').value.trim() || 'Local';
        gameState.rivalTeamName = document.getElementById('rival-name').value.trim() || 'Rival';
        gameState.localPlayers = document.getElementById('local-players').value.split(',').map(s => s.trim()).filter(Boolean);
        gameState.rivalDorsals = document.getElementById('rival-dorsals').value.split(',').map(s => s.trim()).filter(Boolean);
        if (gameState.localPlayers.length < 5 || gameState.rivalDorsals.length < 5) return alert("Se necesitan al menos 5 jugadores/dorsales por equipo.");
        
        initializeStats();
        rebuildUIFromState();
        
        autoPlaceInitialLineup();
        repositionPlayersFromState();
        updateStatsTables();
        checkStartingConditions();

        saveState();
    }
    
    function rebuildUIFromState() {
        document.getElementById('local-name').textContent = gameState.localTeamName;
        document.getElementById('rival-name-display').textContent = gameState.rivalTeamName;
        updateTimerUI();
        setupPitchAndBench();
        rebuildAndRecalculateAllStats();
        renderTimeline();
        updateButtonStates();
        showMatchUI();
    }
    
    function rebuildAndRecalculateAllStats() {
        initializeStats(false); 
        
        let halftimeReset = false;
        gameState.faltas = { local: 0, rival: 0 };
        gameState.matchEvents.forEach(event => {
            if (event.type === 'control' && event.text.includes('Descanso') && !halftimeReset) {
                gameState.faltas = { local: 0, rival: 0 };
                halftimeReset = true;
            }
            if (event.type === 'goal') {
                const { team, goleador, asistente } = event;
                if (gameState.playerStats[team][goleador]) gameState.playerStats[team][goleador].goles++;
                if (asistente && gameState.playerStats[team][asistente]) gameState.playerStats[team][asistente].asistencias++;
            } else if (event.type === 'yellow-card') {
                const { team, player } = event;
                if (gameState.playerStats[team][player]) gameState.playerStats[team][player].amarillas++;
            } else if (event.type === 'red-card') {
                const { team, player } = event;
                if (gameState.playerStats[team][player]) {
                    gameState.playerStats[team][player].rojas++;
                    gameState.playerStats[team][player].expulsado = true;
                }
            } else if (event.type === 'foul') {
                const { team, player } = event;
                gameState.faltas[team]++;
                if (player && gameState.playerStats[team][player]) gameState.playerStats[team][player].faltas++;
            }
        });
        
        recalculateAllPlayerMinutes();

        repositionPlayersFromState();
        updateScoreboard();
        updateFoulCounters();
        updateStatsTables();
    }

    function recalculateAllPlayerMinutes() {
        Object.values(gameState.playerStats.local).forEach(p => p.minutosJugados = 0);
        Object.values(gameState.playerStats.rival).forEach(p => p.minutosJugados = 0);

        if (gameState.matchEvents.length === 0 || !gameState.initialLineup.local.length) return;

        let lineup = {
            local: new Set(gameState.initialLineup.local),
            rival: new Set(gameState.initialLineup.rival)
        };

        let lastEventTime = 0;
        
        const timelineForMinutes = [...gameState.matchEvents, { type: 'current_time', time: gameState.matchTimer }];

        for (const event of timelineForMinutes) {
            const timeSlice = event.time - lastEventTime;

            if (timeSlice > 0) {
                for (const team in lineup) {
                    lineup[team].forEach(playerName => {
                        if (gameState.playerStats[team] && gameState.playerStats[team][playerName]) {
                            gameState.playerStats[team][playerName].minutosJugados += timeSlice;
                        }
                    });
                }
            }
            
            if (event.type === 'substitution') {
                lineup[event.team].delete(event.playerOut);
                lineup[event.team].add(event.playerIn);
            } else if (event.type === 'red-card') {
                lineup[event.team].delete(event.player);
            }
            
            lastEventTime = event.time;
        }
    }
    
    function showMatchUI() {
        document.getElementById('config-section').classList.add('hidden');
        document.getElementById('app-header').style.display = 'block';
        document.getElementById('pitch-section').classList.remove('hidden');
        document.getElementById('game-controls').classList.remove('hidden');
        document.getElementById('stats-section').classList.remove('hidden');
    }
    
    function initializeStats(resetAll = true) {
        const statsToPreserve = ['onPitch', 'position'];
        if (resetAll) {
            gameState.playerStats = { local: {}, rival: {} };
        }
        const initialStats = { onPitch: false, goles: 0, asistencias: 0, amarillas: 0, rojas: 0, faltas: 0, minutosJugados: 0, expulsado: false, position: {left: '0%', top: '0%'} };
        
        const preserveStats = (player, team) => {
            if (resetAll || !gameState.playerStats[team] || !gameState.playerStats[team][player]) return {};
            const preserved = {};
            statsToPreserve.forEach(stat => {
                if(gameState.playerStats[team][player].hasOwnProperty(stat)) {
                    preserved[stat] = gameState.playerStats[team][player][stat];
                }
            });
            return preserved;
        };

        gameState.localPlayers.forEach(p => { gameState.playerStats.local[p] = { ...initialStats, ...preserveStats(p, 'local') }; });
        gameState.rivalDorsals.forEach(d => { gameState.playerStats.rival[d] = { ...initialStats, ...preserveStats(d, 'rival') }; });
    }
    
    // Lógica de Drag & Drop (sistema estándar como futsal-mini)
    function setupDragAndDropForChip(chip) {
        chip.draggable = true;
        chip.addEventListener('dragstart', handleDragStart);
        chip.addEventListener('touchstart', handleTouchStart, {passive: false});
    }
    
    function handleDragStart(e) { 
        if(gameState.eventFlowState.active || e.target.classList.contains('expulsado')) return e.preventDefault(); 
        gameState.draggedElement = e.target; 
        setTimeout(() => e.target.classList.add('dragging'), 0); 
    }
    
    function handleTouchStart(e) { 
        if(gameState.eventFlowState.active || e.target.classList.contains('expulsado')) return; 
        e.preventDefault(); 
        gameState.draggedElement = e.target; 
        gameState.draggedElement.classList.add('dragging'); 
        const touch = e.touches[0]; 
        Object.assign(gameState.draggedElement.style, { position: 'fixed', left: `${touch.clientX}px`, top: `${touch.clientY}px`, transform: `translate(-50%, -50%)`, zIndex: 1000 }); 
        document.addEventListener('touchmove', handleTouchMove, {passive: false}); 
        document.addEventListener('touchend', handleTouchEnd); 
    }

    function handleTouchMove(e) { 
        e.preventDefault(); 
        if(!gameState.draggedElement) return; 
        const touch = e.touches[0]; 
        Object.assign(gameState.draggedElement.style, { left: `${touch.clientX}px`, top: `${touch.clientY}px` }); 
    }

    function handleTouchEnd(e) { 
        if(!gameState.draggedElement) return; 
        const touch = e.changedTouches[0]; 
        gameState.draggedElement.style.position = '';
        gameState.draggedElement.style.zIndex = '';
        handlePlayerDrop(gameState.draggedElement, touch.clientX, touch.clientY); 
        gameState.draggedElement.classList.remove('dragging');
        gameState.draggedElement = null; 
        document.removeEventListener('touchmove', handleTouchMove); 
        document.removeEventListener('touchend', handleTouchEnd); 
    }

    function handleDrop(e) { 
        e.preventDefault(); 
        if (!gameState.draggedElement) return; 
        handlePlayerDrop(gameState.draggedElement, e.clientX, e.clientY); 
        gameState.draggedElement.classList.remove('dragging');
        gameState.draggedElement = null;
    }

    function handlePlayerDrop(draggedChip, clientX, clientY) {
        draggedChip.style.display = 'none';
        const dropTarget = document.elementFromPoint(clientX, clientY);
        draggedChip.style.display = '';
        const targetPlayer = dropTarget?.closest('.player-chip');
        const targetZone = dropTarget?.closest('#futsal-pitch, .bench');
        if (targetPlayer && targetPlayer !== draggedChip) return handleSubstitution(draggedChip, targetPlayer);
        if (targetZone?.id === 'futsal-pitch') return movePlayerToPitch(draggedChip, clientX, clientY);
        if (targetZone?.classList.contains('bench')) return movePlayerToBench(draggedChip, targetZone);
    }
    
    function movePlayerToPitch(chip, clientX, clientY) {
        const { name, team } = chip.dataset;
        const isComingFromBench = chip.classList.contains('chip-on-bench');
        if (isComingFromBench) {
            const onPitchCount = Object.values(gameState.playerStats[team]).filter(p => p.onPitch).length;
            const maxPlayers = getTeamMaxPlayers(team);
            if (onPitchCount >= maxPlayers) {
                alert(`El equipo ${team === 'local' ? gameState.localTeamName : gameState.rivalTeamName} no puede alinear más jugadores.`);
                return;
            }
        }

        const rect = pitch.getBoundingClientRect();
        const x = Math.max(0, Math.min(rect.width, clientX - rect.left));
        const y = Math.max(0, Math.min(rect.height, clientY - rect.top));
        const pos = { left: `${100 * x / rect.width}%`, top: `${100 * y / rect.height}%` };

        chip.className = `player-chip chip-${team} chip-on-pitch`;
        Object.assign(chip.style, { ...pos, transform: 'translate(-50%, -50%)' });
        pitch.appendChild(chip);
        gameState.playerStats[team][name].onPitch = true;
        gameState.playerStats[team][name].position = pos;
        updateStatsTables();
        saveState();
    }
    
    function movePlayerToBench(chip, targetBench) {
        const { name, team } = chip.dataset;
        const isOnPitch = chip.classList.contains('chip-on-pitch');

        if (targetBench.id !== `${team}-bench`) return;
        chip.className = `player-chip chip-${team} chip-on-bench`;
        chip.style.cssText = '';
        targetBench.appendChild(chip);
        gameState.playerStats[team][name].onPitch = false;
        updateStatsTables();
        saveState();
    }

    function handleSubstitution(playerInChip, playerOutChip) {
        const sameTeam = playerInChip.dataset.team === playerOutChip.dataset.team;
        if (!sameTeam) return;

        const { name: nameIn, team } = playerInChip.dataset;
        const { name: nameOut } = playerOutChip.dataset;
        const statsIn = gameState.playerStats[team][nameIn];
        const statsOut = gameState.playerStats[team][nameOut];
        
        // Intercambiar posiciones y estados
        const inPosition = {...statsIn.position};
        const inOnPitch = statsIn.onPitch;
        const outPosition = {...statsOut.position};
        const outOnPitch = statsOut.onPitch;
        
        // Actualizar estados
        statsIn.position = outPosition;
        statsIn.onPitch = outOnPitch;
        statsOut.position = inPosition;
        statsOut.onPitch = inOnPitch;
        
        // Actualizar elementos visuales
        updatePlayerChipVisuals(playerInChip, statsIn, team);
        updatePlayerChipVisuals(playerOutChip, statsOut, team);

        // Solo registrar como sustitución si uno está en el campo y el otro en el banquillo
        const hasStarted = gameState.matchEvents.some(e => e.type === 'init_match');
        if (hasStarted && inOnPitch !== outOnPitch) {
            const playerOnPitch = inOnPitch ? nameIn : nameOut;
            const playerOnBench = inOnPitch ? nameOut : nameIn;
            addMatchEvent({
                type: 'substitution',
                text: `Sustitución: <span style="color: var(--color-success); font-weight: bold;">&uarr; ${playerOnBench}</span> <span style="color: var(--color-danger); font-weight: bold;">&darr; ${playerOnPitch}</span>`,
                team: team,
                playerIn: playerOnBench,
                playerOut: playerOnPitch
            });
        }
        
        updateStatsTables();
        saveState();
    }
    
    function updatePlayerChipVisuals(chip, stats, team) {
        const bench = team === 'local' ? localBench : rivalBench;
        
        if (stats.onPitch) {
            chip.className = `player-chip chip-${team} chip-on-pitch`;
            Object.assign(chip.style, { ...stats.position, transform: 'translate(-50%, -50%)' });
            pitch.appendChild(chip);
        } else {
            chip.className = `player-chip chip-${team} chip-on-bench`;
            chip.style.cssText = '';
            bench.appendChild(chip);
        }
    }

    // --- UI Y EVENTOS ---

    function setupPitchAndBench() {
        localBench.innerHTML = ''; 
        rivalBench.innerHTML = '';
        pitch.querySelectorAll('.player-chip').forEach(chip => chip.remove());
        gameState.localPlayers.forEach(p => localBench.appendChild(createChip(p, 'local')));
        gameState.rivalDorsals.forEach(d => rivalBench.appendChild(createChip(d, 'rival')));
        
        [pitch, localBench, rivalBench].forEach(zone => {
            zone.addEventListener('dragover', (e) => e.preventDefault());
            zone.addEventListener('drop', handleDrop);
        });
    }
    
    function createChip(name, team) {
        const chip = document.createElement('div');
        chip.className = `player-chip chip-${team} chip-on-bench`;
        chip.textContent = name;
        chip.dataset.name = name;
        chip.dataset.team = team;
        setupDragAndDropForChip(chip);
        chip.addEventListener('click', () => processEventSelection(chip));
        
        // Agregar funcionalidad de eliminación (solo antes de iniciar partido)
        let longPressTimer;
        chip.addEventListener('pointerdown', (e) => {
            if (gameState.matchEvents.length > 0) return; // Solo antes de iniciar
            if (chip.classList.contains('chip-on-pitch')) return; // Solo jugadores del banquillo
            
            longPressTimer = setTimeout(() => {
                showDeletePlayerModal(name, team, chip);
            }, 1000); // 1 segundo de presión
        });
        
        chip.addEventListener('pointerup', () => {
            clearTimeout(longPressTimer);
        });
        
        chip.addEventListener('pointerleave', () => {
            clearTimeout(longPressTimer);
        });
        
        return chip;
    }

    function repositionPlayersFromState() {
        const allPlayers = [
            ...gameState.localPlayers.map(p => ({ name: p, team: 'local' })),
            ...gameState.rivalDorsals.map(d => ({ name: d, team: 'rival' }))
        ];

        allPlayers.forEach(({ name, team }) => {
            const stats = gameState.playerStats[team][name];
            let chip = document.querySelector(`.player-chip[data-name="${name}"][data-team="${team}"]`);
            if (!chip) chip = createChip(name, team);
            
            chip.classList.toggle('expulsado', !!stats.expulsado);
            updateChipYellowCardIcon(chip, stats);

            if (stats.onPitch) {
                chip.classList.remove('chip-on-bench');
                chip.classList.add('chip-on-pitch');
                Object.assign(chip.style, { 
                    left: stats.position.left, 
                    top: stats.position.top, 
                    transform: 'translate(-50%, -50%)', 
                    position: 'absolute' 
                });
                pitch.appendChild(chip);
            } else {
                chip.classList.remove('chip-on-pitch');
                chip.classList.add('chip-on-bench');
                chip.style.cssText = '';
                const bench = team === 'local' ? localBench : rivalBench;
                bench.appendChild(chip);
            }
        });
    }

    function updateChipYellowCardIcon(chip, playerStats) {
        let icon = chip.querySelector('.yellow-card-icon');
        if (playerStats.amarillas > 0 && !playerStats.expulsado) {
            if (!icon) {
                icon = document.createElement('div');
                icon.className = 'yellow-card-icon';
                icon.textContent = '🟨';
                chip.appendChild(icon);
            }
        } else if (icon) {
            icon.remove();
        }
    }
    
    function showDeletePlayerModal(playerName, team, chip) {
        const teamName = team === 'local' ? gameState.localTeamName : gameState.rivalTeamName;
        const confirmMessage = `¿Eliminar a ${playerName} del equipo ${teamName}?\n\nEsta acción no se puede deshacer.`;
        
        if (confirm(confirmMessage)) {
            deletePlayer(playerName, team, chip);
        }
    }
    
    function deletePlayer(playerName, team, chip) {
        // Inicializar lista de jugadores eliminados si no existe
        if (!gameState.eliminatedPlayers) {
            gameState.eliminatedPlayers = { local: [], rival: [] };
        }
        
        // Marcar como eliminado
        gameState.eliminatedPlayers[team].push(playerName);
        
        // Eliminar del estado
        delete gameState.playerStats[team][playerName];
        
        // NO eliminar de las listas de jugadores aquí, solo marcar como eliminado
        // Las listas se mantienen para poder recargar desde los inputs si es necesario
        
        // Eliminar del DOM
        chip.remove();
        
        // Actualizar estadísticas
        updateStatsTables();
        saveState();
        
        // Mostrar mensaje de confirmación
        const teamName = team === 'local' ? gameState.localTeamName : gameState.rivalTeamName;
        alert(`${playerName} ha sido eliminado del equipo ${teamName}.`);
    }
    
    function updateStatsTables() {
        const generateCellContent = (value) => (value > 0) ? `<span class="stat-highlight">${value}</span>` : '0';
        
        const updateTable = (tbody, players, team) => {
            if (!tbody) return;
            tbody.innerHTML = '';
            players.forEach(name => {
                const stats = gameState.playerStats[team][name] || { minutosJugados: 0 };
                const row = tbody.insertRow();
                row.innerHTML = `<td>${name}</td><td>${generateCellContent(stats.goles)}</td><td>${generateCellContent(stats.asistencias)}</td><td>${generateCellContent(stats.amarillas)}</td><td>${generateCellContent(stats.rojas)}</td><td>${generateCellContent(stats.faltas)}</td><td>${formatTimeAscending(stats.minutosJugados)}</td>`;
                if (stats.onPitch) row.classList.add('player-on-pitch');
            });
        };

        updateTable(document.querySelector('#local-stats-table tbody'), gameState.localPlayers, 'local');
        updateTable(document.querySelector('#rival-stats-table tbody'), gameState.rivalDorsals, 'rival');
    }

    function addMatchEvent(eventData) {
        const newEvent = { id: Date.now() + Math.random(), time: gameState.matchTimer, ...eventData };
        gameState.matchEvents.push(newEvent);
        gameState.matchEvents.sort((a, b) => a.time - b.time);
        rebuildAndRecalculateAllStats();
        renderTimeline();
        saveState();
    }
    
    function renderTimeline() {
        document.getElementById('timeline-section').classList.toggle('hidden', gameState.matchEvents.length === 0);

        timelineContainer.innerHTML = '';
        gameState.matchEvents.forEach(event => {
            const time = formatTimeAscending(event.time);
            const eventEl = document.createElement('div');
            eventEl.className = 'timeline-event';
            eventEl.dataset.eventId = event.id;
            eventEl.innerHTML = `<div class="timeline-event-main"><span class="event-icon">${getEventIcon(event.type)}</span><div><strong>${time}</strong> - ${event.text}</div></div>`;
            
            let pressTimer;
            eventEl.addEventListener('pointerdown', (e) => {
                if (e.pointerType === 'touch') {
                    pressTimer = setTimeout(() => showContextMenu(e, event.id), 500);
                }
            });
            eventEl.addEventListener('pointerup', () => clearTimeout(pressTimer));
            eventEl.addEventListener('pointerleave', () => clearTimeout(pressTimer));
            eventEl.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                showContextMenu(e, event.id);
            });
            timelineContainer.appendChild(eventEl);
        });
        timelineContainer.scrollTop = timelineContainer.scrollHeight;
    }
    
    function showContextMenu(e, eventId) {
        const menu = document.getElementById('context-menu');
        menu.classList.remove('hidden');
        
        let x = e.clientX;
        let y = e.clientY;

        const menuWidth = menu.offsetWidth;
        const menuHeight = menu.offsetHeight;
        if (x + menuWidth > window.innerWidth) x = window.innerWidth - menuWidth - 5;
        if (y + menuHeight > window.innerHeight) y = window.innerHeight - menuHeight - 5;

        menu.style.left = `${x}px`;
        menu.style.top = `${y}px`;
        
        document.getElementById('ctx-menu-edit').onclick = () => {
            menu.classList.add('hidden');
            openEditEventModal(eventId);
        };
        
        document.getElementById('ctx-menu-delete').onclick = () => {
            menu.classList.add('hidden');
            if (confirm('¿Seguro que quieres borrar este evento?')) {
                gameState.matchEvents = gameState.matchEvents.filter(ev => ev.id != eventId);
                rebuildAndRecalculateAllStats();
                renderTimeline();
                saveState();
            }
        };
    }
    
    // --- MODALES ---
    
    let tempTime = { minutes: 20, seconds: 0 };

    function openEditTimeModal() {
        if (timerInterval || gameState.isMatchFinished || gameState.matchEvents.length === 0) return; 
        const remainingSeconds = getRemainingSecondsInCurrentHalf(gameState.matchTimer);
        const mins = Math.floor(remainingSeconds / 60);
        const secs = Math.floor(remainingSeconds % 60);
        
        document.getElementById('time-editor-min').value = mins;
        document.getElementById('time-editor-sec').value = secs;
        editTimeModal.classList.remove('hidden');
    }

    function adjustTimeValue(unit, delta) {
        const input = document.getElementById(`time-editor-${unit}`);
        let value = parseInt(input.value) || 0;
        value += delta;
        
        if (unit === 'min') {
            if (value < 0) value = 0;
            if (value > 25) value = 25;
        } else if (unit === 'sec') {
            if (value < 0) {
                value = 59;
                const minInput = document.getElementById('time-editor-min');
                const minValue = parseInt(minInput.value) || 0;
                if (minValue > 0) {
                    minInput.value = minValue - 1;
                }
            }
            if (value > 59) {
                value = 0;
                const minInput = document.getElementById('time-editor-min');
                const minValue = parseInt(minInput.value) || 0;
                if (minValue < 25) {
                    minInput.value = minValue + 1;
                }
            }
        }
        
        input.value = value.toString().padStart(2, '0');
    }

    function handleSaveTimeEdit() {
        const newMins = parseInt(document.getElementById('time-editor-min').value) || 0;
        const newSecs = parseInt(document.getElementById('time-editor-sec').value) || 0;
        const newRemainingSecondsInHalf = (newMins * 60) + newSecs;
        
        const halfOffset = gameState.currentHalf === 2 ? HALF_TIME_SECONDS : 0;
        gameState.matchTimer = halfOffset + (HALF_TIME_SECONDS - newRemainingSecondsInHalf);
        
        rebuildAndRecalculateAllStats();
        updateTimerUI();
        
        editTimeModal.classList.add('hidden');
        saveState();
        
        if (gameState.currentHalf === 1 && gameState.matchTimer >= HALF_TIME_SECONDS) handleHalfTime();
        else if (gameState.currentHalf === 2 && gameState.matchTimer >= 2 * HALF_TIME_SECONDS) handleFinishGame();
        updateButtonStates();
    }
    
    let tempEventTime = { minutes: 0, seconds: 0 };

    function createPlayerSelect(label, id, players, selectedValue, includeNoneOption = false) {
        let options = players.map(p => `<option value="${p}" ${p === selectedValue ? 'selected' : ''}>${p}</option>`).join('');
        if (includeNoneOption) {
            options = `<option value="" ${!selectedValue ? 'selected' : ''}>-- Ninguno --</option>` + options;
        }
        return `<label for="${id}">${label}:</label><select id="${id}">${options}</select>`;
    }

    function openEditEventModal(eventId) {
        const event = gameState.matchEvents.find(e => e.id == eventId);
        if (!event) return;

        editEventModal.dataset.editingEventId = eventId;
        const titleEl = document.getElementById('edit-modal-title');
        const timeEditorEl = document.getElementById('edit-event-time-editor');
        const dynamicFieldsEl = document.getElementById('edit-event-dynamic-fields');

        tempEventTime.minutes = Math.floor(event.time / 60);
        tempEventTime.seconds = Math.floor(event.time % 60);
        
        timeEditorEl.innerHTML = `
            <div class="time-editor">
                <div class="time-adjust-group">
                    <button class="time-editor-btn btn-secondary" data-type="event" data-unit="minutes" data-action="decrease">-</button>
                    <span id="edit-event-minutes-display" class="time-editor-display">${String(tempEventTime.minutes).padStart(2, '0')}</span>
                    <button class="time-editor-btn btn-secondary" data-type="event" data-unit="minutes" data-action="increase">+</button>
                </div>
                <span class="time-editor-separator">:</span>
                <div class="time-adjust-group">
                    <button class="time-editor-btn btn-secondary" data-type="event" data-unit="seconds" data-action="decrease">-</button>
                    <span id="edit-event-seconds-display" class="time-editor-display">${String(tempEventTime.seconds).padStart(2, '0')}</span>
                    <button class="time-editor-btn btn-secondary" data-type="event" data-unit="seconds" data-action="increase">+</button>
                </div>
            </div>`;

        const teamPlayers = event.team === 'local' ? gameState.localPlayers : gameState.rivalDorsals;
        dynamicFieldsEl.innerHTML = '';
        switch(event.type) {
            case 'goal':
                titleEl.textContent = 'Editar Gol';
                dynamicFieldsEl.innerHTML += createPlayerSelect('Goleador', 'edit-goleador', teamPlayers, event.goleador);
                dynamicFieldsEl.innerHTML += createPlayerSelect('Asistente', 'edit-asistente', teamPlayers, event.asistente, true);
                break;
            case 'yellow-card':
            case 'red-card':
            case 'foul':
                titleEl.textContent = `Editar ${event.type === 'foul' ? 'Falta' : 'Tarjeta'}`;
                dynamicFieldsEl.innerHTML += createPlayerSelect('Jugador', 'edit-player', teamPlayers, event.player);
                break;
            case 'substitution':
                titleEl.textContent = 'Editar Sustitución';
                dynamicFieldsEl.innerHTML += createPlayerSelect('Entra', 'edit-playerIn', teamPlayers, event.playerIn);
                dynamicFieldsEl.innerHTML += createPlayerSelect('Sale', 'edit-playerOut', teamPlayers, event.playerOut);
                break;
            default:
                titleEl.textContent = 'Editar Evento';
                timeEditorEl.innerHTML = '';
        }
        
        timeEditorEl.querySelectorAll('.time-editor-btn').forEach(btn => btn.addEventListener('click', adjustEventTimeInModal));
        
        editEventModal.classList.remove('hidden');
    }
    
    function adjustEventTimeInModal(e) {
        const { unit, action } = e.currentTarget.dataset;
        const amount = action === 'increase' ? 1 : -1;
        
        let totalSeconds = (tempEventTime.minutes * 60) + tempEventTime.seconds;
        if (unit === 'minutes') totalSeconds += amount * 60;
        if (unit === 'seconds') totalSeconds += amount;
        
        totalSeconds = Math.max(0, totalSeconds);

        tempEventTime.minutes = Math.floor(totalSeconds / 60);
        tempEventTime.seconds = totalSeconds % 60;

        document.getElementById('edit-event-minutes-display').textContent = String(tempEventTime.minutes).padStart(2, '0');
        document.getElementById('edit-event-seconds-display').textContent = String(tempEventTime.seconds).padStart(2, '0');
    }

    function handleSaveEventEdit() {
        const eventId = editEventModal.dataset.editingEventId;
        const event = gameState.matchEvents.find(e => e.id == eventId);
        if (!event) return;

        event.time = (tempEventTime.minutes * 60) + tempEventTime.seconds;

        switch(event.type) {
            case 'goal':
                event.goleador = document.getElementById('edit-goleador').value;
                event.asistente = document.getElementById('edit-asistente').value || null;
                event.text = `GOL de <strong>${event.goleador}</strong>.` + (event.asistente ? ` Asistencia de <strong>${event.asistente}</strong>.` : '');
                break;
            case 'yellow-card':
            case 'red-card':
                event.player = document.getElementById('edit-player').value;
                event.text = `Tarjeta ${event.type === 'yellow-card' ? 'Amarilla' : 'ROJA'} para <strong>${event.player}</strong>.`;
                break;
            case 'foul':
                event.player = document.getElementById('edit-player').value;
                event.text = `Falta de <strong>${event.player}</strong>.`;
                break;
            case 'substitution':
                 event.playerIn = document.getElementById('edit-playerIn').value;
                 event.playerOut = document.getElementById('edit-playerOut').value;
                 event.text = `Sustitución: <span style="color: var(--color-success); font-weight: bold;">&uarr; ${event.playerIn}</span> <span style="color: var(--color-danger); font-weight: bold;">&darr; ${event.playerOut}</span>`;
                 break;
        }

        gameState.matchEvents.sort((a, b) => a.time - b.time);
        rebuildAndRecalculateAllStats();
        renderTimeline();
        saveState();
        editEventModal.classList.add('hidden');
    }

    // --- FUNCIONES AUXILIARES ---

    function updateButtonStates() { 
        const hasStarted = gameState.matchEvents.some(e => e.type === 'init_match');
        const isRunning = !!timerInterval;
        document.getElementById('btn-toggle-timer').textContent = isRunning ? "PAUSAR" : (hasStarted ? "REANUDAR" : "INICIAR PARTIDO");
        document.getElementById('btn-toggle-timer').disabled = gameState.isMatchFinished || (!hasStarted && document.getElementById('btn-toggle-timer').textContent.startsWith('Faltan'));
        document.getElementById('btn-half-time').disabled = !hasStarted || gameState.isMatchFinished || gameState.currentHalf !== 1;
        document.getElementById('btn-start-second').disabled = !hasStarted || gameState.isMatchFinished || gameState.currentHalf !== 2 || isRunning;
        document.getElementById('btn-finish-game').disabled = !hasStarted || gameState.isMatchFinished;
        
        // CORRECCIÓN 3: La lógica de los botones de eventos se asegura de que solo estén activos
        // después de que el partido haya comenzado y antes de que termine.
        // Esto funciona tanto si el cronómetro está corriendo como si está pausado, lo cual es
        // correcto para poder registrar eventos que ocurren justo cuando se detiene el tiempo.
        document.querySelectorAll('.btn-event').forEach(b => b.disabled = !hasStarted || gameState.isMatchFinished);

        minutoActualDisplay.classList.toggle('editable', !isRunning && hasStarted && !gameState.isMatchFinished);
    }
    
    function handleHalfTime() {
        pauseTimer();
        gameState.matchTimer = HALF_TIME_SECONDS;
        if (!gameState.matchEvents.some(e => e.type === 'control' && e.text === 'Descanso.')) {
            addMatchEvent({ type: 'control', text: 'Descanso.' });
        }
        gameState.currentHalf = 2;
        rebuildAndRecalculateAllStats();
        updateDocumentTitle(`DESCANSO`, false, true);
        saveState();
    }

    function handleStartSecondHalf() {
        if(gameState.currentHalf !== 2) return;
        addMatchEvent({ type: 'control', text: 'Inicio de la segunda parte.' });
        startTimer();
    }

    function handleFinishGame(isPassive = false) {
        pauseTimer();
        gameState.matchTimer = 2 * HALF_TIME_SECONDS;
        gameState.isMatchFinished = true;
        if (!gameState.matchEvents.some(e => e.type === 'control' && e.text === 'Final del partido.')) {
            addMatchEvent({ type: 'control', text: 'Final del partido.' });
        }
        rebuildAndRecalculateAllStats();
        document.getElementById('btn-export-excel').classList.remove('hidden');
        updateDocumentTitle(`FINAL`, false, true);
        if (!isPassive) {
            localStorage.removeItem(APP_STATE_KEY);
            localStorage.removeItem(TIMER_STATE_KEY);
        }
    }
    
    function handleResetMatch() {
        if (!confirm("¿Seguro que quieres reiniciar este partido? Se reseteará el marcador, el tiempo y las posiciones.")) return;
        pauseTimer();
        const originalConfig = { localTeamName: gameState.localTeamName, rivalTeamName: gameState.rivalTeamName, localPlayers: gameState.localPlayers, rivalDorsals: gameState.rivalDorsals };
        
        gameState = getInitialGameState();
        Object.assign(gameState, originalConfig);
        
        initializeStats();
        rebuildUIFromState();
        
        autoPlaceInitialLineup();
        repositionPlayersFromState();
        checkStartingConditions();

        localStorage.removeItem(TIMER_STATE_KEY);
        saveState();
    }

    function handleNewMatch() {
        if (confirm("¿Estás seguro de empezar un partido nuevo de cero? Se perderá el partido actual y guardado.")) {
            isNavigatingIntentionally = true;
            localStorage.removeItem(APP_STATE_KEY);
            localStorage.removeItem(TIMER_STATE_KEY);
            location.reload();
        }
    }
    
    function handleQuickFoul(team) {
        // CORRECCIÓN 2: Verificar si el partido ha empezado antes de registrar el evento
        const hasStarted = gameState.matchEvents.some(e => e.type === 'init_match');
        if (!hasStarted) return alert("El partido debe estar en juego para registrar eventos.");

        pauseTimer();
        addMatchEvent({ type: 'foul', text: `Falta de <strong>${team === 'local' ? gameState.localTeamName : gameState.rivalTeamName}</strong>.`, team, player: null });
        checkSixthFoul(team);
        startTimer();
    }
    
    function updateFoulCounters() {
        const localFouls = gameState.faltas.local;
        const rivalFouls = gameState.faltas.rival;
        const localCounter = document.getElementById('local-foul-counter');
        const rivalCounter = document.getElementById('rival-foul-counter');
        localCounter.textContent = localFouls;
        rivalCounter.textContent = rivalFouls;
        localCounter.classList.toggle('foul-warning', localFouls >= 5);
        rivalCounter.classList.toggle('foul-warning', rivalFouls >= 5);
    }

    function checkSixthFoul(team) {
        if (gameState.faltas[team] >= 6) {
            const opponentTeamName = team === 'local' ? gameState.rivalTeamName : gameState.localTeamName;
            showEventMessage(`<strong>¡DOBLE PENALTI</strong> a favor de ${opponentTeamName}!`);
            setTimeout(hideEventMessage, 4000);
        }
    }

    function autoPlaceInitialLineup() {
        const localTeam = [...gameState.localPlayers].sort(() => 0.5 - Math.random());
        const rivalTeam = [...gameState.rivalDorsals].sort(() => 0.5 - Math.random());
        const localStarting5 = localTeam.slice(0, 5);
        const rivalStarting5 = rivalTeam.slice(0, 5);
        const formation = {
            local: [ {left: '10%', top: '50%'}, {left: '25%', top: '25%'}, {left: '25%', top: '75%'}, {left: '40%', top: '35%'}, {left: '40%', top: '65%'} ],
            rival: [ {left: '90%', top: '50%'}, {left: '75%', top: '25%'}, {left: '75%', top: '75%'}, {left: '60%', top: '35%'}, {left: '60%', top: '65%'} ]
        };
        Object.values(gameState.playerStats.local).forEach(p => p.onPitch = false);
        Object.values(gameState.playerStats.rival).forEach(p => p.onPitch = false);
        
        localStarting5.forEach((player, index) => { if (gameState.playerStats.local[player]) { gameState.playerStats.local[player].onPitch = true; gameState.playerStats.local[player].position = formation.local[index]; } });
        rivalStarting5.forEach((player, index) => { if (gameState.playerStats.rival[player]) { gameState.playerStats.rival[player].onPitch = true; gameState.playerStats.rival[player].position = formation.rival[index]; } });
    }

    function handleEventButtonClick(e) {
        // CORRECCIÓN 2: Verificar si el partido ha empezado antes de registrar el evento
        const hasStarted = gameState.matchEvents.some(e => e.type === 'init_match');
        if (!hasStarted) return alert("El partido debe estar en juego para registrar eventos.");
        
        const eventType = e.currentTarget.dataset.event;
        document.getElementById('pitch-section').scrollIntoView({ behavior: 'smooth', block: 'center' });
        startEventFlow(eventType);
    }
    
    function startEventFlow(type) {
        pauseTimer();
        gameState.eventFlowState = { active: true, type, step: 1, payload: {} };
        mainContainer.classList.add('selecting-mode');
        let message = "Haz clic en el jugador implicado";
        if(type === 'goal') message = "Selecciona al <strong>goleador</strong>";
        if(type === 'foul') message = "Selecciona al <strong>infractor</strong>";
        showEventMessage(message + "<br><small>(Haz clic aquí para cancelar)</small>");
    }

    function processEventSelection(chip) { 
        if (!gameState.eventFlowState.active || !chip.classList.contains('chip-on-pitch') || chip.classList.contains('expulsado')) return; 
        const { type, step } = gameState.eventFlowState; 
        const { name, team } = chip.dataset; 
        
        if (type === 'goal') { 
            const opposingTeam = team === 'local' ? 'rival' : 'local';
            endActivePenalty(opposingTeam, `Gol de ${team === 'local' ? gameState.localTeamName : gameState.rivalTeamName}.`);
            
            if (step === 1) { 
                gameState.eventFlowState.payload = { goleador: name, team }; 
                gameState.eventFlowState.step = 2; 
                showEventMessage(`GOL de <strong>${name}</strong>. Ahora selecciona al <strong>asistente</strong> (o pulsa de nuevo en el goleador).<br><small>(Clic para cancelar)</small>`); 
            } else if (step === 2) { 
                const { goleador } = gameState.eventFlowState.payload; 
                const asistente = (name !== goleador) ? name : null; 
                addMatchEvent({ type: 'goal', text: `GOL de <strong>${goleador}</strong>.` + (asistente ? ` Asistencia de <strong>${asistente}</strong>.` : ''), team, goleador, asistente }); 
                endEventFlow(); 
            } 
        
        } else if (type === 'yellow-card') {
            const playerStats = gameState.playerStats[team][name];
            if (playerStats.amarillas === 1) {
                addMatchEvent({ type: 'red-card', text: `Tarjeta ROJA para <strong>${name}</strong> por doble amarilla.`, team, player: name });
                gameState.playerStats[team][name].onPitch = false;
                startPenalty(team);
            } else {
                addMatchEvent({ type, text: `Tarjeta Amarilla para <strong>${name}</strong>.`, team, player: name });
            }
            endEventFlow();
        } else if (type === 'red-card') { 
            addMatchEvent({ type, text: `Tarjeta ROJA directa para <strong>${name}</strong>.`, team, player: name });
            gameState.playerStats[team][name].onPitch = false;
            startPenalty(team);
            endEventFlow(); 
        } else if (type === 'foul') { 
            addMatchEvent({ type, text: `Falta de <strong>${name}</strong>.`, team, player: name }); 
            endEventFlow(); 
        } 
    }
    
    function endEventFlow(cancelled = false) { 
        gameState.eventFlowState.active = false; 
        mainContainer.classList.remove('selecting-mode'); 
        hideEventMessage(); 
        if (!cancelled && !gameState.isMatchFinished) {
             startTimer();
        }
    }

    function checkStartingConditions() { 
        const localOnPitch = Object.values(gameState.playerStats.local).filter(p => p.onPitch).length; 
        const rivalOnPitch = Object.values(gameState.playerStats.rival).filter(p => p.onPitch).length;
        const btnToggleTimer = document.getElementById('btn-toggle-timer');
        if (localOnPitch === 5 && rivalOnPitch === 5) { 
            btnToggleTimer.disabled = false; 
            btnToggleTimer.textContent = "INICIAR PARTIDO"; 
        } else { 
            btnToggleTimer.disabled = true; 
            let message = []; 
            if (5 - localOnPitch > 0) message.push(`${5 - localOnPitch} locales`); 
            if (5 - rivalOnPitch > 0) message.push(`${5 - rivalOnPitch} rivales`); 
            btnToggleTimer.textContent = `Faltan ${message.join(' y ')}`; 
        } 
    }

    function startPenalty(team) {
        const teamName = team === 'local' ? gameState.localTeamName : gameState.rivalTeamName;
        showEventMessage(`<strong>${teamName}</strong> jugará con 4 jugadores durante 2 minutos.`);
        setTimeout(hideEventMessage, 4000);
        gameState.penalties.push({
            team: team,
            endTime: gameState.matchTimer + PENALTY_DURATION_SECONDS,
            active: true
        });
    }

    function endActivePenalty(team, reason) {
        const activePenalty = gameState.penalties.find(p => p.team === team && p.active);
        if (activePenalty) {
            activePenalty.active = false;
            const teamName = team === 'local' ? gameState.localTeamName : gameState.rivalTeamName;
            const message = `${reason} Fin de la sanción para <strong>${teamName}</strong>. Ya puede incorporar a un 5º jugador.`;
            addMatchEvent({ type: 'control', text: message });
            showEventMessage(message);
            setTimeout(hideEventMessage, 5000);
        }
    }
    
    function checkPenalties() {
        gameState.penalties.forEach(penalty => {
            if (penalty.active && gameState.matchTimer >= penalty.endTime) {
                endActivePenalty(penalty.team, 'Tiempo de sanción cumplido.');
            }
        });
    }

    function getTeamMaxPlayers(team) {
        const hasActivePenalty = gameState.penalties.some(p => p.team === team && p.active);
        return hasActivePenalty ? 4 : 5;
    }
    
    function getRemainingSecondsInCurrentHalf(totalMatchSeconds) {
        const halfStartTime = (gameState.currentHalf - 1) * HALF_TIME_SECONDS;
        const elapsedInHalf = totalMatchSeconds - halfStartTime;
        return Math.max(0, HALF_TIME_SECONDS - elapsedInHalf);
    }
    
    function getEventIcon(type) {
        const icons = { goal: '⚽', 'yellow-card': '🟨', 'red-card': '🟥', foul: '✋', substitution: '🔄', control: '⏱️', init_match: '▶️' };
        return icons[type] || 'ℹ️';
    }
    function showEventMessage(msg) {
        eventFlowMessage.innerHTML = msg;
        eventFlowMessage.classList.remove('hidden');
    }
    function hideEventMessage() {
        eventFlowMessage.classList.add('hidden');
    }
    function updateScoreboard() {
        const localScore = gameState.matchEvents.filter(e => e.type === 'goal' && e.team === 'local').length;
        const rivalScore = gameState.matchEvents.filter(e => e.type === 'goal' && e.team === 'rival').length;
        document.getElementById('local-score').textContent = localScore;
        document.getElementById('rival-score').textContent = rivalScore;
        updateDocumentTitle(formatTime(gameState.matchTimer));
    }
    function updateDocumentTitle(time, background = false, forceText = false) {
        if (document.hidden && !background) return;
        const localScore = document.getElementById('local-score').textContent;
        const rivalScore = document.getElementById('rival-score').textContent;
        document.title = forceText ? `${time} | Futsal` : `${time} | ${gameState.localTeamName} ${localScore}-${rivalScore} ${gameState.rivalTeamName}`;
    }
    
    function exportToCsv() { 
        let csvContent = "data:text/csv;charset=utf-8,"; 
        const headers = ["Jugador/Dorsal", "Goles", "Asistencias", "Amarillas", "Rojas", "Faltas", "Minutos Jugados"]; 
        const localTeamName = gameState.localTeamName || 'Local'; 
        const rivalTeamName = gameState.rivalTeamName || 'Rival'; 
        const createTeamSection = (teamName, players, stats) => { 
            csvContent += teamName + "\r\n"; 
            csvContent += headers.join(",") + "\r\n"; 
            players.forEach(p => { 
                const s = stats[p] || {}; 
                const row = [p, s.goles || 0, s.asistencias || 0, s.amarillas || 0, s.rojas || 0, s.faltas || 0, formatTimeAscending(s.minutosJugados || 0)].join(","); 
                csvContent += row + "\r\n"; 
            }); 
            csvContent += "\r\n"; 
        }; 
        createTeamSection(localTeamName, gameState.localPlayers, gameState.playerStats.local); 
        createTeamSection(rivalTeamName, gameState.rivalDorsals, gameState.playerStats.rival); 

        csvContent += "Cronologia del Partido\r\n";
        csvContent += "Tiempo,Descripcion\r\n";
        gameState.matchEvents.forEach(event => {
            const time = formatTimeAscending(event.time);
            const description = `"${event.text.replace(/<[^>]*>/g, '')}"`;
            csvContent += `${time},${description}\r\n`;
        });
        
        const encodedUri = encodeURI(csvContent); 
        const link = document.createElement("a"); 
        link.setAttribute("href", encodedUri); 
        link.setAttribute("download", `estadisticas_${localTeamName}_vs_${rivalTeamName}.csv`); 
        document.body.appendChild(link); 
        link.click(); 
        document.body.removeChild(link); 
    }

</script>
</body>
</html>