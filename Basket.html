<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Baloncesto T√°ctico Interactivo</title>
    
    <style>
        :root {
            --color-background: #1a1a1a;
            --color-surface: #2c2c2c;
            --color-primary: #007bff;
            --color-secondary: #6c757d;
            --color-success: #28a745;
            --color-danger: #dc3545;
            --color-warning: #ffc107;
            --color-text: #f8f9fa;
            --color-pitch: #d2691e;
            --color-pitch-lines: rgba(255, 255, 255, 0.9);
        }
        
        *,
        *::before,
        *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        html,
        body {
            width: 100%;
            height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--color-background);
            color: var(--color-text);
            scroll-behavior: smooth;
        }
        
        main {
            padding: 15px;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        section {
            background-color: var(--color-surface);
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        h2 {
            font-size: 1.4em;
            border-bottom: 2px solid var(--color-primary);
            padding-bottom: 10px;
            margin-bottom: 15px;
        }
        #app-header {
            display: none;
            text-align: center;
        }
        
        #marcador {
            font-size: 2em;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 15px;
            background: rgba(0, 0, 0, 0.2);
            padding: 10px 20px;
            border-radius: 8px;
        }
        
        .team-info {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.8em;
        }
        
        .team-info.local {
            justify-content: flex-end;
        }
        
        .team-info.rival {
            justify-content: flex-start;
        }
        
        #tiempo {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 15px;
            gap: 10px;
        }
        #minuto-actual {
            font-size: 1.3em;
            font-weight: bold;
            background: #111;
            border: 1px solid #555;
            padding: 8px 12px;
            border-radius: 6px;
            width: 90px;
            text-align: center;
        }
        
        #minuto-actual.editable:hover {
            cursor: pointer;
            border-color: var(--color-warning);
        }
        
        #added-time {
            font-size: 1.1em;
            font-weight: bold;
            color: var(--color-warning);
            margin-left: -5px;
        }
        
        button {
            padding: 12px 18px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        
        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        button:active:not(:disabled) {
            transform: translateY(0);
        }
        
        button:disabled {
            background-color: #444 !important;
            color: #888 !important;
            cursor: not-allowed;
            opacity: 0.7;
            border-color: #444 !important;
        }
        .btn-primary {
            background: linear-gradient(145deg, var(--color-primary), #0056b3);
            color: white;
        }
        
        .btn-secondary {
            background: var(--color-secondary);
            color: white;
        }
        
        .btn-danger {
            background: linear-gradient(145deg, var(--color-danger), #a71d2a);
            color: white;
        }
        
        .btn-warning {
            background: linear-gradient(145deg, var(--color-warning), #d39e00);
            color: black;
        }
        
        .btn-event {
            background-color: transparent;
            color: var(--color-warning);
            border: 2px solid var(--color-warning);
        }
        
        .control-group,
        .event-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        
        label {
            display: block;
            margin-top: 15px;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        input,
        textarea,
        select {
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            border: 1px solid #555;
            background-color: #333;
            color: var(--color-text);
            border-radius: 6px;
            font-size: 1em;
        }
        #pitch-section {
            position: relative;
        }
        
        #event-flow-message {
            position: absolute;
            top: 10px;
            left: 50%;
            width: 90%;
            max-width: 400px;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 12px 22px;
            border-radius: 25px;
            z-index: 1001;
            font-size: 1em;
            border: 1px solid var(--color-primary);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            text-align: center;
            cursor: pointer;
        }
        
        .selecting-mode {
            cursor: crosshair !important;
        }
        
        #basketball-court {
            position: relative;
            width: 100%;
            aspect-ratio: 94 / 50;
            background-color: var(--color-pitch);
            border: 3px solid var(--color-pitch-lines);
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }
        
        .basketball-court-lines svg {
            width: 100%;
            height: 100%;
        }
        
        
        #bench-container {
            display: block;
            margin-top: 15px;
            gap: 15px;
        }
        
        .bench {
            width: 100%;
            min-height: 100px;
            border: 2px dashed #555;
            border-radius: 8px;
            padding: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-content: flex-start;
            justify-content: center;
            background: rgba(0, 0, 0, 0.2);
        }
        
        .player-chip {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: grab;
            user-select: none;
            position: relative;
            touch-action: none;
            width: 55px;
        }
        
        .chip-circle {
            width: 38px;
            height: 38px;
            font-size: 15px;
            border-radius: 50%;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            border: 2px solid white;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.5);
            transition: box-shadow 0.2s;
            position: relative;
        }
        
        .chip-label {
            font-size: 10px;
            margin-top: 4px;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
            text-align: center;
            width: 100%;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .chip-local .chip-circle {
            background-color: var(--color-primary);
        }
        
        .chip-rival .chip-circle {
            background-color: var(--color-danger);
        }

        .chip-on-bench {
            position: static;
        }
        
        .chip-on-pitch {
            position: absolute;
            z-index: 10;
            transform: translate(-50%, -50%);
        }
        
        .dragging {
            cursor: grabbing !important;
            opacity: 0.8;
            z-index: 1000 !important;
            position: fixed !important;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.6) !important;
            transition: none !important;
            transform: none !important;
        }
        
        .has-yellow-card .chip-circle::before {
            content: 'üü®';
            position: absolute;
            top: -5px;
            left: -5px;
            font-size: 14px;
            line-height: 1;
            text-shadow: 0 0 3px black;
            z-index: 1;
        }
        .expulsado {
            filter: grayscale(100%);
            cursor: not-allowed !important;
            opacity: 0.5;
        }
        
        .expulsado .chip-circle::after {
            content: 'üü•';
            position: absolute;
            top: -5px;
            right: -5px;
            font-size: 14px;
            line-height: 1;
            text-shadow: 0 0 3px black;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            font-size: 0.85em;
            table-layout: fixed;
        }
        
        th,
        td {
            padding: 10px 5px;
            text-align: center;
            border-bottom: 1px solid #444;
            word-break: break-word;
            vertical-align: middle;
        }
        
        th:first-child,
        td:first-child {
            width: 28%;
            text-align: left;
        }
        
        th:not(:first-child),
        td:not(:first-child) {
            width: 10.2%;
        }
        
        table td:last-child {
            white-space: nowrap;
        }

        td .stat-value-circle {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 26px;
            height: 26px;
            margin: 0 auto;
            border-radius: 50%;
            font-weight: bold;
            color: var(--color-background);
            font-size: 0.9em;
        }
        .stat-value-circle.goal {
            background-color: var(--color-success);
        }
        
        .stat-value-circle.yellow {
            background-color: var(--color-warning);
            color: #111;
        }
        
        .stat-value-circle.red {
            background-color: var(--color-danger);
        }
        
        .stat-value-circle.generic {
            background-color: var(--color-primary);
        }

        thead {
            background-color: rgba(0, 0, 0, 0.3);
        }
        
        tbody tr:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }
        
        .player-on-pitch {
            background-color: rgba(0, 123, 255, 0.2);
            font-weight: bold;
        }
        
        .modal {
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
        }
        
        .modal.visible {
            display: flex;
        }
        
        .modal-content {
            background: var(--color-surface);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            width: 90%;
            max-width: 500px;
        }
        
        .time-editor-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
        }
        .time-editor-unit {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .time-editor-buttons {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .time-editor-buttons button {
            font-size: 1.2em;
            padding: 0;
            width: 40px;
            height: 35px;
            line-height: 35px;
            background-color: var(--color-secondary);
        }
        .time-editor-unit input {
            width: 80px;
            height: 75px;
            font-size: 3em;
            font-weight: bold;
            text-align: center;
            border: 2px solid #555;
            -moz-appearance: textfield;
            appearance: textfield;
        }
        .time-editor-unit input::-webkit-outer-spin-button,
        .time-editor-unit input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .time-editor-separator {
            font-size: 3em;
            font-weight: bold;
            padding-bottom: 5px;
        }

        #quarter-duration-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin: 20px 0;
        }
        
        .hidden {
            display: none !important;
        }
        
        #match-stats-section .stat-grid {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-top: 15px;
        }
        
        .stat-row {
            display: grid;
            grid-template-columns: 50px 1fr 50px;
            align-items: center;
            text-align: center;
            font-weight: bold;
        }
        
        .stat-value {
            font-size: 1.4em;
        }
        
        .stat-bar-container {
            padding: 0 15px;
        }
        
        .stat-bar-container span {
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            opacity: 0.8;
        }
        
        .stat-bar {
            background-color: #111;
            border-radius: 5px;
            height: 12px;
            width: 100%;
            display: flex;
            overflow: hidden;
            margin-top: 4px;
            border: 1px solid #444;
        }
        
        .stat-bar-local {
            background-color: var(--color-primary);
            height: 100%;
            transition: width 0.5s ease;
        }
        
        #substitution-windows-display {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 5px;
            background-color: rgba(0, 0, 0, 0.2);
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 0.9em;
            font-weight: bold;
        }
        
        .sub-windows-half {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        #sub-windows-divider {
            margin: 0 8px;
        }
        
        .window-box {
            display: inline-block;
            width: 20px;
            height: 20px;
            line-height: 20px;
            border: 1px solid #666;
            text-align: center;
            border-radius: 3px;
            background: #333;
            transition: all 0.3s;
        }
        
        .window-box.used {
            background: var(--color-warning);
            color: #111;
            font-weight: bold;
        }
        
        .window-box.used.can-undo {
            cursor: pointer;
            border-color: white;
        }
        
        .window-box.used.can-undo:hover {
            transform: scale(1.2);
        }
        
        .window-box.active-window {
            border-color: var(--color-warning);
            box-shadow: 0 0 8px var(--color-warning);
        }
        
        .timeline-event {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding: 8px;
            border-radius: 6px;
            transition: background-color 0.2s;
            user-select: none;
        }
        
        .timeline-event.editable:hover {
            background-color: rgba(255, 255, 255, 0.1);
            cursor: pointer;
        }
        
        .timeline-event-text {
            flex-grow: 1;
            pointer-events: none;
        }
        
        .timeline-event-controls {
            display: none;
        }

        #timeline-context-menu {
            display: none;
            position: fixed;
            z-index: 3000;
            width: auto;
            padding: 10px;
            gap: 10px;
            flex-direction: row;
        }
        
        #timeline-context-menu button {
            padding: 8px 12px;
            font-size: 0.9em;
        }

        @media (max-width: 768px) {
            main {
                padding: 10px;
                max-width: 100%;
            }
            
            section {
                padding: 15px;
            }
            
            .chip-circle {
                width: 34px;
                height: 34px;
                font-size: 13px;
            }
            
            .player-chip {
                width: 48px;
            }
            
            .chip-label {
                font-size: 9px;
            }
            
            #marcador {
                font-size: 1.5em;
            }
            
            .team-info {
                font-size: 0.7em;
            }
            
            .event-group {
                grid-template-columns: 1fr 1fr;
            }
        }
    </style>
</head>
<body>
    <main>
        <section id="config-section">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2 style="margin: 0;">Configuraci√≥n del Partido</h2>
                <button id="btn-home" class="btn-secondary" style="display: flex; align-items: center; gap: 8px; padding: 10px 15px;">
                    <span style="font-size: 1.2em;">üè†</span>
                    <span>Men√∫ Principal</span>
                </button>
            </div>
            <label for="local-name-input">Nombre Equipo Local:</label>
            <input type="text" id="local-name-input" value="Equipo Local">
            <label for="rival-name">Nombre Rival:</label>
            <input type="text" id="rival-name" value="Equipo Rival">
            <label for="local-players">Jugadores Locales (Nombres o dorsales separados por coma):</label>
            <textarea id="local-players" rows="3">ERIK, FRAN, JUANJO, DANY, RGUEZ, GAEL, CESAR, RUBIA, NICO, JOEL, JAVIER, RUIZ, ALEX, VICTOR, MARTIN, UNAI, HUGO</textarea>
            <label for="rival-dorsals">Dorsales Rivales (separados por coma):</label>
            <textarea id="rival-dorsals" rows="3">1,2,3,4,5,6,7,8,9,10,11,12,13,14</textarea>
            <button id="start-config" class="btn-primary">Guardar y Preparar Pizarra</button>
        </section>

        <header id="app-header">
            <div id="marcador">
                <div class="team-info local"><span id="local-name"></span></div>
                <div class="score-display"><span id="local-score">0</span> - <span id="rival-score">0</span></div>
                <div class="team-info rival"><span id="rival-name-display"></span></div>
            </div>
            <div id="tiempo">
                <button id="btn-toggle-timer" class="btn-primary" disabled>Ajusta Alineaciones</button>
                <input type="text" id="minuto-actual" value="00:00" readonly>
                <span id="added-time" class="hidden"></span>
            </div>
        </header>

        <section id="pitch-section" class="hidden">
            <h2>Pizarra T√°ctica</h2>
            <div id="event-flow-message" class="hidden"></div>
            <div id="basketball-court">
                <div class="basketball-court-lines"><svg viewBox="0 0 94 50" preserveAspectRatio="xMidYMid meet">
                    <!-- Fondo de la cancha -->
                    <rect x="0" y="0" width="94" height="50" fill="var(--color-pitch)"/>
                    
                    <!-- L√≠neas exteriores (rect√°ngulo completo) -->
                    <rect x="0" y="0" width="94" height="50" stroke="var(--color-pitch-lines)" stroke-width="0.8" fill="none"/>
                    
                    <!-- L√≠nea central (mitad de cancha) -->
                    <line x1="47" y1="0" x2="47" y2="50" stroke="var(--color-pitch-lines)" stroke-width="0.8"/>
                    
                    <!-- C√≠rculo central -->
                    <circle cx="47" cy="25" r="5.8" stroke="var(--color-pitch-lines)" stroke-width="0.8" fill="none"/>
                    <circle cx="47" cy="25" r="0.5" fill="var(--color-pitch-lines)"/>
                    
                    <!-- Zona izquierda (local) - Canasta en x=5.25 -->
                    <!-- L√≠nea de fondo izquierda -->
                    <line x1="0" y1="0" x2="0" y2="50" stroke="var(--color-pitch-lines)" stroke-width="0.8"/>
                    
                    <!-- L√≠nea de tiros libres (paralela a la l√≠nea de fondo) -->
                    <line x1="0" y1="17.5" x2="19" y2="17.5" stroke="var(--color-pitch-lines)" stroke-width="0.8"/>
                    <line x1="0" y1="32.5" x2="19" y2="32.5" stroke="var(--color-pitch-lines)" stroke-width="0.8"/>
                    
                    <!-- Zona restringida (rect√°ngulo) -->
                    <rect x="0" y="17.5" width="19" height="15" stroke="var(--color-pitch-lines)" stroke-width="0.8" fill="none"/>
                    
                    <!-- C√≠rculo de tiros libres (semic√≠rculo) -->
                    <path d="M 0 17.5 A 5.8 5.8 0 0 1 0 32.5" stroke="var(--color-pitch-lines)" stroke-width="0.8" fill="none"/>
                    
                    <!-- Canasta izquierda (aro) -->
                    <circle cx="5.25" cy="25" r="1.2" stroke="var(--color-pitch-lines)" stroke-width="0.8" fill="none"/>
                    <!-- L√≠nea desde la l√≠nea de fondo hasta el aro -->
                    <line x1="0" y1="25" x2="5.25" y2="25" stroke="var(--color-pitch-lines)" stroke-width="0.8"/>
                    
                    <!-- L√≠nea de 3 puntos (arco) -->
                    <path d="M 0 3.5 A 23.75 23.75 0 0 1 0 46.5" stroke="var(--color-pitch-lines)" stroke-width="0.8" fill="none"/>
                    <!-- L√≠neas rectas de 3 puntos -->
                    <line x1="0" y1="3.5" x2="23.75" y2="3.5" stroke="var(--color-pitch-lines)" stroke-width="0.8"/>
                    <line x1="0" y1="46.5" x2="23.75" y2="46.5" stroke="var(--color-pitch-lines)" stroke-width="0.8"/>
                    
                    <!-- Zona derecha (rival) - Canasta en x=88.75 -->
                    <!-- L√≠nea de fondo derecha -->
                    <line x1="94" y1="0" x2="94" y2="50" stroke="var(--color-pitch-lines)" stroke-width="0.8"/>
                    
                    <!-- L√≠nea de tiros libres (paralela a la l√≠nea de fondo) -->
                    <line x1="94" y1="17.5" x2="75" y2="17.5" stroke="var(--color-pitch-lines)" stroke-width="0.8"/>
                    <line x1="94" y1="32.5" x2="75" y2="32.5" stroke="var(--color-pitch-lines)" stroke-width="0.8"/>
                    
                    <!-- Zona restringida (rect√°ngulo) -->
                    <rect x="75" y="17.5" width="19" height="15" stroke="var(--color-pitch-lines)" stroke-width="0.8" fill="none"/>
                    
                    <!-- C√≠rculo de tiros libres (semic√≠rculo) -->
                    <path d="M 94 17.5 A 5.8 5.8 0 0 0 94 32.5" stroke="var(--color-pitch-lines)" stroke-width="0.8" fill="none"/>
                    
                    <!-- Canasta derecha (aro) -->
                    <circle cx="88.75" cy="25" r="1.2" stroke="var(--color-pitch-lines)" stroke-width="0.8" fill="none"/>
                    <!-- L√≠nea desde la l√≠nea de fondo hasta el aro -->
                    <line x1="94" y1="25" x2="88.75" y2="25" stroke="var(--color-pitch-lines)" stroke-width="0.8"/>
                    
                    <!-- L√≠nea de 3 puntos (arco) -->
                    <path d="M 94 3.5 A 23.75 23.75 0 0 0 94 46.5" stroke="var(--color-pitch-lines)" stroke-width="0.8" fill="none"/>
                    <!-- L√≠neas rectas de 3 puntos -->
                    <line x1="94" y1="3.5" x2="70.25" y2="3.5" stroke="var(--color-pitch-lines)" stroke-width="0.8"/>
                    <line x1="94" y1="46.5" x2="70.25" y2="46.5" stroke="var(--color-pitch-lines)" stroke-width="0.8"/>
                </svg></div>
            </div>
            <div id="bench-container"><div id="local-bench" class="bench"></div><div id="rival-bench" class="bench"></div></div>
        </section>

        <section id="game-controls" class="hidden">
            <div id="substitution-windows-display">
                <span>Ventanas (Local):</span>
                <div id="sub-windows-first-half" class="sub-windows-half">
                    <span style="margin-left: 5px;">1¬™P:</span>
                </div>
                <span id="sub-windows-divider" class="hidden">|</span>
                <div id="sub-windows-second-half" class="sub-windows-half hidden">
                    <span style="margin-left: 5px;">2¬™P:</span>
                </div>
            </div>
             <div class="event-group">
                  <button class="btn-event" data-event="basket-3">CANASTA 3PT üèÄ</button>
                  <button class="btn-event" data-event="basket-2">CANASTA 2PT üèÄ</button>
                  <button class="btn-event" data-event="basket-1">TIRO LIBRE üèÄ</button>
                  <button class="btn-event" data-event="shot">TIRO üí•</button>
                  <button class="btn-event" data-event="foul">FALTA ‚úã</button>
                  <button class="btn-event" data-event="technical-foul">FALTA T√âCNICA üü®</button>
                  <button class="btn-event" data-event="ejection">EXPULSI√ìN üü•</button>
             </div>
            <div class="control-group">
                <button id="btn-end-quarter" class="btn-secondary" disabled>Fin del Cuarto</button><button id="btn-start-next-quarter" class="btn-secondary" disabled>Inicio Siguiente Cuarto</button>
                <button id="btn-finish-game" class="btn-danger" disabled>Finalizar</button>
            </div>
        </section>
        
        <section id="timeline-section" class="hidden">
            <h2>Cronolog√≠a del Partido</h2>
            <div id="event-timeline" style="max-height: 200px; overflow-y: auto; padding-right: 10px;"></div>
        </section>

        <section id="match-stats-section" class="hidden">
            <h2>Estad√≠sticas del Partido</h2>
            <div class="stat-grid">
                <div class="stat-row"><span class="stat-value local-stat" id="stat-local-shots">0</span><div class="stat-bar-container"><span>Tiros</span><div class="stat-bar"><div class="stat-bar-local" id="stat-bar-shots" style="width: 50%;"></div></div></div><span class="stat-value rival-stat" id="stat-rival-shots">0</span></div>
                <div class="stat-row"><span class="stat-value local-stat" id="stat-local-rebounds">0</span><div class="stat-bar-container"><span>Rebotes</span><div class="stat-bar"><div class="stat-bar-local" id="stat-bar-rebounds" style="width: 50%;"></div></div></div><span class="stat-value rival-stat" id="stat-rival-rebounds">0</span></div>
                <div class="stat-row"><span class="stat-value local-stat" id="stat-local-steals">0</span><div class="stat-bar-container"><span>Robos</span><div class="stat-bar"><div class="stat-bar-local" id="stat-bar-steals" style="width: 50%;"></div></div></div><span class="stat-value rival-stat" id="stat-rival-steals">0</span></div>
                <div class="stat-row"><span class="stat-value local-stat" id="stat-local-blocks">0</span><div class="stat-bar-container"><span>Tapones</span><div class="stat-bar"><div class="stat-bar-local" id="stat-bar-blocks" style="width: 50%;"></div></div></div><span class="stat-value rival-stat" id="stat-rival-blocks">0</span></div>
                <div class="stat-row"><span class="stat-value local-stat" id="stat-local-technical">0</span><div class="stat-bar-container"><span>Faltas T√©cnicas</span><div class="stat-bar"><div class="stat-bar-local" id="stat-bar-technical" style="width: 50%;"></div></div></div><span class="stat-value rival-stat" id="stat-rival-technical">0</span></div>
                <div class="stat-row"><span class="stat-value local-stat" id="stat-local-ejections">0</span><div class="stat-bar-container"><span>Expulsiones</span><div class="stat-bar"><div class="stat-bar-local" id="stat-bar-ejections" style="width: 50%;"></div></div></div><span class="stat-value rival-stat" id="stat-rival-ejections">0</span></div>
            </div>
        </section>
        
        <section id="stats-section" class="hidden">
            <h2>Estad√≠sticas de Jugadores</h2>
            <h3 id="local-stats-title"></h3>
            <table id="local-stats-table"><thead><tr><th>Jugador</th><th>P</th><th>A</th><th>R</th><th>RO</th><th>T</th><th>F</th><th>üü®</th><th>üü•</th><th>‚è±Ô∏è</th></tr></thead><tbody></tbody></table>
            <h3 id="rival-stats-title" style="margin-top: 20px;"></h3>
            <table id="rival-stats-table"><thead><tr><th>Dorsal</th><th>P</th><th>A</th><th>R</th><th>RO</th><th>T</th><th>F</th><th>üü®</th><th>üü•</th><th>‚è±Ô∏è</th></tr></thead><tbody></tbody></table>
            <div class="control-group" style="margin-top: 20px;">
                <button id="btn-reset-match" class="btn-secondary">Reiniciar</button>
                <button id="btn-new-match" class="btn-secondary">Nuevo Partido</button>
            </div>
            <button id="btn-export-excel" class="btn-primary hidden" style="margin-top: 20px; width: 100%;">Exportar a Excel</button>
        </section>
        
        <div id="quarter-duration-modal" class="modal">
            <div class="modal-content">
                <h3 id="quarter-duration-modal-title">Selecciona la duraci√≥n de cada cuarto</h3>
                <div id="quarter-duration-buttons" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin: 20px 0;">
                    <button id="quarter-8min" class="btn-primary" style="padding: 20px; font-size: 1.2em;">8 minutos</button>
                    <button id="quarter-10min" class="btn-primary" style="padding: 20px; font-size: 1.2em;">10 minutos</button>
                    <button id="quarter-12min" class="btn-primary" style="padding: 20px; font-size: 1.2em;">12 minutos</button>
                </div>
            </div>
        </div>
        
        <div id="time-editor-modal" class="modal">
            <div class="modal-content">
                <h3>Ajustar Tiempo del Partido</h3>
                <div id="time-editor-content">
                    <div class="time-editor-container">
                        <div class="time-editor-unit">
                            <div class="time-editor-buttons">
                                <button id="time-editor-min-plus">+</button>
                                <button id="time-editor-min-minus">-</button>
                            </div>
                            <input type="number" id="time-editor-min" min="0" max="120">
                        </div>
                        <span class="time-editor-separator">:</span>
                        <div class="time-editor-unit">
                            <input type="number" id="time-editor-sec" min="0" max="59">
                            <div class="time-editor-buttons">
                                <button id="time-editor-sec-plus">+</button>
                                <button id="time-editor-sec-minus">-</button>
                            </div>
                        </div>
                    </div>
                    <div style="text-align: center; display:flex; gap: 10px; justify-content: center;">
                        <button id="save-time-btn" class="btn-primary">Guardar</button>
                        <button id="cancel-time-btn" class="btn-secondary">Cancelar</button>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="edit-event-modal" class="modal">
            <div class="modal-content">
                <h3 id="edit-event-title"></h3>
                <div id="edit-event-content" style="margin-top: 15px;"></div>
                <div style="margin-top: 20px; display: flex; gap: 10px; justify-content: flex-end;">
                    <button id="save-edit-btn" class="btn-primary">Guardar Cambios</button>
                    <button id="cancel-edit-btn" class="btn-secondary">Cancelar</button>
                </div>
            </div>
        </div>
    </main>

    <div id="timeline-context-menu" class="modal-content">
        <button id="context-edit-btn" class="btn-secondary">‚úèÔ∏è Editar</button>
        <button id="context-delete-btn" class="btn-danger">üóëÔ∏è Borrar</button>
    </div>

<script>
    'use strict';
    
    const AppConfig = {
        QUARTER_DURATION_MINUTES: 10,
        QUARTER_DURATION_SECONDS: 10 * 60,
        MAX_QUARTERS: 4,
        SUBSTITUTION_WINDOW_SECONDS: 25,
        MAX_PLAYERS_ON_PITCH: 5,
        MAX_SUBSTITUTION_WINDOWS: 4,
        MAX_SUBSTITUTION_WINDOWS_SECOND_HALF: 3,
        APP_STATE_KEY: 'basketballTacticoState_v1',
        TIMER_INTERVAL_MS: 1000,
        MAX_TIME_MINUTES: 120,
        MAX_TIME_SECONDS: 59,
        LONG_PRESS_DELAY_MS: 1000,
        TIMELINE_PRESS_DELAY_MS: 500,
        DRAG_THRESHOLD_PX: 5,
        EVENT_ICONS: {
            'basket': 'üèÄ',
            'shot': 'üí•',
            'foul': '‚úã',
            'technical-foul': 'üü®',
            'ejection': 'üü•',
            'init_match': '‚ñ∂Ô∏è',
            'control': '‚è∏Ô∏è',
            'substitution': 'üîÑ'
        }
    };

    const AppState = {
        _state: {},
        getInitial() {
            return {
                localTeamName: 'Local', rivalTeamName: 'Rival', localPlayers: [], rivalDorsals: [],
                playerStats: { local: {}, rival: {} }, initialPlayerState: null,
                matchStats: { local: {}, rival: {} },
                matchTimer: 0, timerStartTime: 0, timerBaseTime: 0, isMatchRunning: false,
                currentQuarter: 1, timerInterval: null, lastMinuteCheck: -1,
                matchEvents: [], eventFlow: { active: false },
                substitutionWindows: { usedFirstHalf: 0, usedSecondHalf: 0 },
                eliminatedPlayers: { local: [], rival: [] }
            };
        },
        init() { this._state = this.getInitial(); },
        load() {
            const savedStateJSON = localStorage.getItem(AppConfig.APP_STATE_KEY);
            if (!savedStateJSON) return false;
            try {
                const loadedState = JSON.parse(savedStateJSON);
                delete loadedState.timerInterval;
                this._state = { ...this.getInitial(), ...loadedState };
                if (!this._state.eliminatedPlayers) {
                    this._state.eliminatedPlayers = { local: [], rival: [] };
                }
                return true;
            } catch (e) {
                console.error("Error al cargar estado, reseteando.", e);
                localStorage.removeItem(AppConfig.APP_STATE_KEY);
                return false;
            }
        },
        save() {
            const stateToSave = {...this._state};
            delete stateToSave.timerInterval;
            localStorage.setItem(AppConfig.APP_STATE_KEY, JSON.stringify(stateToSave));
        },
        get() { return this._state; },
        set(newState) { this._state = newState; }
    };

    const DOM = {
        elements: {},
        cacheElements() {
            const ids = [
                'config-section', 'app-header', 'pitch-section', 'game-controls', 'timeline-section',
                'match-stats-section', 'stats-section', 'local-name-input', 'rival-name',
                'local-players', 'rival-dorsals', 'start-config', 'btn-home', 'btn-toggle-timer', 'minuto-actual', 'added-time',
                'basketball-court', 'local-bench', 'rival-bench', 'event-timeline', 'quarter-duration-modal',
                'quarter-duration-modal-title', 'quarter-duration-buttons', 'quarter-8min', 'quarter-10min', 'quarter-12min', 'event-flow-message',
                'btn-end-quarter', 'btn-start-next-quarter', 'btn-finish-game', 'btn-reset-match', 'btn-new-match', 
                'btn-export-excel', 'local-name', 'rival-name-display', 'local-score', 'rival-score',
                'local-stats-title', 'rival-stats-title', 'local-stats-table', 'rival-stats-table',
                'substitution-windows-display',
                'sub-windows-first-half', 'sub-windows-second-half', 'sub-windows-divider',
                'time-editor-modal', 'time-editor-min', 'time-editor-sec',
                'save-time-btn', 'cancel-time-btn', 'edit-event-modal', 'edit-event-title', 'edit-event-content',
                'save-edit-btn', 'cancel-edit-btn',
                'timeline-context-menu', 'context-edit-btn', 'context-delete-btn'
            ];
            ids.forEach(id => this.elements[id] = document.getElementById(id));
            this.elements.eventButtons = document.querySelectorAll('.btn-event');
        },
        showMatchUI() {
            this.elements['config-section'].classList.add('hidden');
            this.elements['app-header'].style.display = 'block';
            ['pitch-section', 'game-controls', 'timeline-section', 'match-stats-section', 'stats-section']
                .forEach(id => this.elements[id].classList.remove('hidden'));
        },
        updateAll() {
            const state = AppState.get();
            this.elements['local-name'].textContent = state.localTeamName;
            this.elements['rival-name-display'].textContent = state.rivalTeamName;
            this.elements['local-stats-title'].textContent = state.localTeamName;
            this.elements['rival-stats-title'].textContent = state.rivalTeamName;
            this.updateTimerDisplay();
            this.updateButtonStates();
            this.updateScoreboard();
            this.updatePlayerChips();
            this.updateStatsTables();
            this.updateMatchStats();
            this.renderTimeline();
            this.updateDocumentTitle();
            this.updateTeamView();
            this.updateSubstitutionWindowsUI();
        },
        updateTimerDisplay() {
            const state = AppState.get();
            const mainTimerEl = this.elements['minuto-actual'];
            const addedTimeEl = this.elements['added-time'];
            
            const quarterTimeLimit = state.currentQuarter * AppConfig.QUARTER_DURATION_SECONDS;
            
            if (state.matchTimer >= quarterTimeLimit) {
                mainTimerEl.value = MatchLogic.formatTime(quarterTimeLimit);
                const addedSeconds = state.matchTimer - quarterTimeLimit;
                addedTimeEl.textContent = `+${MatchLogic.formatTime(addedSeconds)}`;
                addedTimeEl.classList.remove('hidden');
            } else {
                mainTimerEl.value = MatchLogic.formatTime(state.matchTimer);
                addedTimeEl.classList.add('hidden');
            }
        },
        setupBenchesAndPitch() {
            const state = AppState.get();
            this.elements['local-bench'].innerHTML = '';
            this.elements['rival-bench'].innerHTML = '';
            this.elements['basketball-court'].querySelectorAll('.player-chip').forEach(chip => chip.remove());
            
            state.localPlayers.forEach(p => {
                if (!state.eliminatedPlayers.local.includes(p)) {
                    this.elements['local-bench'].appendChild(this.createChip(p, 'local'));
                }
            });
            state.rivalDorsals.forEach(d => {
                if (!state.eliminatedPlayers.rival.includes(d)) {
                    this.elements['rival-bench'].appendChild(this.createChip(d, 'rival'));
                }
            });
        },
        placeInitialFivePlayers() {
            const state = AppState.get();
            
            // Posiciones iniciales t√≠picas de baloncesto (en porcentajes)
            // Formaci√≥n b√°sica: Base, Escolta, Alero, Ala-p√≠vot, P√≠vot
            const initialPositions = [
                { left: '47%', top: '20%' },   // Base (centro superior)
                { left: '65%', top: '25%' },   // Escolta (derecha superior)
                { left: '30%', top: '25%' },  // Alero (izquierda superior)
                { left: '60%', top: '60%' },  // Ala-p√≠vot (derecha inferior)
                { left: '47%', top: '70%' }   // P√≠vot (centro inferior)
            ];
            
            // Colocar 5 jugadores del equipo local
            const localAvailable = state.localPlayers.filter(p => 
                !state.eliminatedPlayers.local.includes(p) && 
                state.playerStats.local[p] &&
                !state.playerStats.local[p].onPitch
            );
            
            const localToPlace = localAvailable.slice(0, 5);
            localToPlace.forEach((playerName, index) => {
                if (index < initialPositions.length) {
                    const pos = { ...initialPositions[index] };
                    MatchLogic.setPlayerOnPitch(playerName, 'local', pos);
                }
            });
            
            // Colocar 5 jugadores del equipo rival (posiciones espejo)
            const rivalPositions = [
                { left: '53%', top: '20%' },   // Base (centro superior, lado contrario)
                { left: '35%', top: '25%' },   // Escolta (izquierda superior, lado contrario)
                { left: '70%', top: '25%' },   // Alero (derecha superior, lado contrario)
                { left: '40%', top: '60%' },  // Ala-p√≠vot (izquierda inferior, lado contrario)
                { left: '53%', top: '70%' }   // P√≠vot (centro inferior, lado contrario)
            ];
            
            const rivalAvailable = state.rivalDorsals.filter(d => 
                !state.eliminatedPlayers.rival.includes(d) && 
                state.playerStats.rival[d] &&
                !state.playerStats.rival[d].onPitch
            );
            
            const rivalToPlace = rivalAvailable.slice(0, 5);
            rivalToPlace.forEach((playerName, index) => {
                if (index < rivalPositions.length) {
                    const pos = { ...rivalPositions[index] };
                    MatchLogic.setPlayerOnPitch(playerName, 'rival', pos);
                }
            });
        },
        isNumeric(str) {
            return typeof str === "string" && !isNaN(str) && !isNaN(parseFloat(str));
        },
        createChip(name, team) {
            const chip = document.createElement('div');
            chip.className = `player-chip chip-${team}`;
            chip.dataset.name = name;
            chip.dataset.team = team;

            const circle = document.createElement('div');
            circle.className = 'chip-circle';
            
            if (this.isNumeric(name)) {
                circle.textContent = name;
                chip.appendChild(circle);
            } else {
                const label = document.createElement('span');
                label.className = 'chip-label';
                label.textContent = name;
                chip.appendChild(circle);
                chip.appendChild(label);
            }

            chip.addEventListener('pointerdown', DragAndDrop.start.bind(DragAndDrop));
            chip.addEventListener('click', () => {
                if (AppState.get().eventFlow.active) EventHandler.processEventSelection(chip);
            });
            
            let longPressTimer;
            chip.addEventListener('pointerdown', (e) => {
                const state = AppState.get();
                if (state.matchEvents.length > 0) {
                    return;
                }
                if (chip.classList.contains('chip-on-pitch')) {
                    return;
                }
                
                longPressTimer = setTimeout(() => {
                    this.showDeletePlayerModal(name, team, chip);
                }, AppConfig.LONG_PRESS_DELAY_MS);
            });
            
            chip.addEventListener('pointerup', () => {
                clearTimeout(longPressTimer);
            });
            
            chip.addEventListener('pointerleave', () => {
                clearTimeout(longPressTimer);
            });
            
            return chip;
        },
        showDeletePlayerModal(playerName, team, chip) {
            const state = AppState.get();
            const teamName = team === 'local' ? state.localTeamName : state.rivalTeamName;
            const confirmMessage = `¬øEliminar a ${playerName} del equipo ${teamName}?\n\nEsta acci√≥n no se puede deshacer.`;
            
            if (confirm(confirmMessage)) {
                this.deletePlayer(playerName, team, chip);
            }
        },
        deletePlayer(playerName, team, chip) {
            const state = AppState.get();
            
            // Inicializar lista de jugadores eliminados si no existe
            if (!state.eliminatedPlayers) {
                state.eliminatedPlayers = { local: [], rival: [] };
            }
            
            state.eliminatedPlayers[team].push(playerName);
            delete state.playerStats[team][playerName];
            chip.remove();
            this.updateStatsTables();
            AppState.save();
            const teamName = team === 'local' ? state.localTeamName : state.rivalTeamName;
            alert(`${playerName} ha sido eliminado del equipo ${teamName}.`);
        },
        updatePlayerChips() {
            const state = AppState.get();
            
            // Crear un mapa de chips existentes para acceso r√°pido
            const existingChips = new Map();
            document.querySelectorAll('.player-chip').forEach(chip => {
                const key = `${chip.dataset.name}|${chip.dataset.team}`;
                existingChips.set(key, chip);
            });
            
            // Procesar todos los jugadores del estado
            Object.keys(state.playerStats).forEach(team => {
                Object.keys(state.playerStats[team]).forEach(playerName => {
                    const stats = state.playerStats[team][playerName];
                    const chipKey = `${playerName}|${team}`;
                    let chip = existingChips.get(chipKey);
                    
                    // Si el chip no existe, crearlo
                    if (!chip) {
                        chip = this.createChip(playerName, team);
                        existingChips.set(chipKey, chip);
                    }
                    
                    // Si el chip est√° siendo arrastrado, no modificarlo
                    if (chip.classList.contains('dragging')) {
                        return;
                    }
                    
                    // Actualizar estado visual del chip
                    const hasTechnical = stats.faltasTecnicas >= 1 && !stats.expulsado;
                    chip.classList.toggle('has-yellow-card', hasTechnical);
                    chip.classList.toggle('expulsado', stats.expulsado);
                    chip.draggable = !stats.expulsado;

                    // Determinar el contenedor objetivo
                    const targetParent = stats.onPitch 
                        ? this.elements['basketball-court'] 
                        : this.elements[`${team}-bench`];
                    
                    // Mover el chip al contenedor correcto si es necesario
                    if (chip.parentElement !== targetParent) {
                        targetParent.appendChild(chip);
                    }
                    
                    // Actualizar clases CSS
                    chip.classList.toggle('chip-on-pitch', stats.onPitch);
                    chip.classList.toggle('chip-on-bench', !stats.onPitch);
                    
                    // Actualizar posici√≥n si est√° en el campo
                    if (stats.onPitch && stats.position) {
                        Object.assign(chip.style, stats.position, {
                            transform: 'translate(-50%, -50%)',
                            display: ''
                        });
                    } else {
                        chip.style.cssText = '';
                    }
                });
            });
            
            // Limpiar chips hu√©rfanos (que existen en el DOM pero no en el estado)
            // Esto previene acumulaci√≥n de elementos en el DOM
            document.querySelectorAll('.player-chip').forEach(chip => {
                const playerName = chip.dataset.name;
                const team = chip.dataset.team;
                if (!state.playerStats[team] || !state.playerStats[team][playerName]) {
                    chip.remove();
                }
            });
            
            this.updateTeamView();
        },
        updateScoreboard() {
            const state = AppState.get();
            
            const calculateScore = (teamStats) => 
                Object.values(teamStats).reduce((sum, p) => sum + p.puntos, 0);
            
            const localScore = calculateScore(state.playerStats.local);
            const rivalScore = calculateScore(state.playerStats.rival);
            
            this.elements['local-score'].textContent = localScore;
            this.elements['rival-score'].textContent = rivalScore;
        },
        updateButtonStates() {
            const state = AppState.get();
            const started = state.matchEvents.some(e => e.type === 'init_match');
            const finished = state.matchEvents.some(e => e.text.includes('Final'));
            const timerButton = this.elements['btn-toggle-timer'];

            if (!started) {
                timerButton.textContent = "INICIAR PARTIDO";
                timerButton.className = "btn-primary";
                timerButton.disabled = !MatchLogic.checkStartingConditions();
            } else if (finished) {
                timerButton.textContent = "Partido Finalizado";
                timerButton.className = "btn-secondary";
                timerButton.disabled = true;
            } else if (state.isMatchRunning) {
                timerButton.textContent = "Pausar ‚è∏Ô∏è";
                timerButton.className = "btn-warning";
                timerButton.disabled = false;
            } else {
                timerButton.textContent = "Reanudar ‚ñ∂Ô∏è";
                timerButton.className = "btn-primary";
                timerButton.disabled = false;
            }
            
            this.elements['minuto-actual'].classList.toggle('editable', started && !state.isMatchRunning && !finished);
            this.elements['btn-end-quarter'].disabled = !started || finished || state.currentQuarter >= AppConfig.MAX_QUARTERS || state.isMatchRunning;
            this.elements['btn-start-next-quarter'].disabled = !started || finished || state.currentQuarter >= AppConfig.MAX_QUARTERS || state.isMatchRunning;
            this.elements['btn-finish-game'].disabled = !started || finished;
            this.elements.eventButtons.forEach(b => b.disabled = !started || finished || !state.isMatchRunning);
        },
        renderTimeline() {
            const state = AppState.get();
            const timelineEl = this.elements['event-timeline'];
            timelineEl.innerHTML = '';
            
            const iconMap = AppConfig.EVENT_ICONS;
            const events = state.matchEvents.slice().reverse();
            
            events.forEach(event => {
                const el = document.createElement('div');
                const isEditable = event.type !== 'init_match' && event.type !== 'control';
                
                el.className = `timeline-event${isEditable ? ' editable' : ''}`;
                el.innerHTML = `<span class="timeline-event-text"><span style="opacity: 0.7;">Min ${event.minute}'</span> - ${iconMap[event.type] || ''} ${event.text}</span>`;
                
                if (isEditable) {
                    let pressTimer = null;
                    const openMenu = (e) => {
                        e.preventDefault();
                        EventHandler.openTimelineContextMenu(event.id, e.clientX, e.clientY);
                    };
                    
                    el.addEventListener('contextmenu', openMenu);
                    
                    el.addEventListener('pointerdown', e => {
                        pressTimer = window.setTimeout(() => openMenu(e), AppConfig.TIMELINE_PRESS_DELAY_MS);
                    });

                    const cancelPress = () => clearTimeout(pressTimer);
                    el.addEventListener('pointerup', cancelPress);
                    el.addEventListener('pointerleave', cancelPress);
                }

                timelineEl.appendChild(el);
            });
        },
        updateStatsTables() {
            const state = AppState.get();
            
            const highlightStat = (value, type) => {
                if (value > 0) {
                    return `<div class="stat-value-circle ${type}">${value}</div>`;
                }
                return value;
            };

            const buildTable = (team, players) => {
                const tbody = this.elements[`${team}-stats-table`].querySelector('tbody');
                tbody.innerHTML = '';
                players.forEach(name => {
                    const stats = state.playerStats[team]?.[name];
                    if (!stats) return;
                    const row = tbody.insertRow();
                    row.innerHTML = `
                        <td>${name}</td>
                        <td>${highlightStat(stats.puntos, 'goal')}</td>
                        <td>${highlightStat(stats.asistencias, 'generic')}</td>
                        <td>${highlightStat(stats.rebotes, 'generic')}</td>
                        <td>${highlightStat(stats.robos, 'generic')}</td>
                        <td>${highlightStat(stats.tapones, 'generic')}</td>
                        <td>${highlightStat(stats.faltas, 'generic')}</td>
                        <td>${highlightStat(stats.faltasTecnicas, 'yellow')}</td>
                        <td>${highlightStat(stats.expulsiones, 'red')}</td>
                        <td>${MatchLogic.formatMinutesRoundedUp(stats.minutosJugados)}'</td>
                    `;
                    if (stats.onPitch) row.classList.add('player-on-pitch');
                });
            };
            buildTable('local', state.localPlayers);
            buildTable('rival', state.rivalDorsals);
        },
        updateMatchStats() {
            const state = AppState.get();
            
            const calculateTeamStats = (teamStats) => {
                return Object.values(teamStats).reduce((acc, player) => ({
                    shots: acc.shots + player.tiros,
                    rebounds: acc.rebounds + player.rebotes,
                    steals: acc.steals + player.robos,
                    blocks: acc.blocks + player.tapones,
                    technical: acc.technical + player.faltasTecnicas,
                    ejections: acc.ejections + player.expulsiones
                }), { shots: 0, rebounds: 0, steals: 0, blocks: 0, technical: 0, ejections: 0 });
            };

            const localStats = calculateTeamStats(state.playerStats.local);
            const rivalStats = calculateTeamStats(state.playerStats.rival);
            
            const stats = {
                local: { ...localStats, ...state.matchStats.local },
                rival: { ...rivalStats, ...state.matchStats.rival }
            };

            const updateRow = (type, localValue, rivalValue) => {
                const localEl = document.getElementById(`stat-local-${type}`);
                const rivalEl = document.getElementById(`stat-rival-${type}`);
                const barEl = document.getElementById(`stat-bar-${type}`);
                
                localEl && (localEl.textContent = localValue);
                rivalEl && (rivalEl.textContent = rivalValue);
                
                if (barEl) {
                    const total = localValue + rivalValue;
                    const percentage = total > 0 ? (localValue / total) * 100 : 50;
                    barEl.style.width = `${percentage}%`;
                }
            };

            const statTypes = ['shots', 'rebounds', 'steals', 'blocks', 'technical', 'ejections'];
            statTypes.forEach(type => updateRow(type, stats.local[type] || 0, stats.rival[type] || 0));
        },
        updateDocumentTitle() {
            const state = AppState.get();
            const time = MatchLogic.formatTime(state.matchTimer);
            const score = `${state.localTeamName} ${this.elements['local-score'].textContent}-${this.elements['rival-score'].textContent} ${state.rivalTeamName}`;
            
            let prefix = 'Preparaci√≥n';
            const hasFinal = state.matchEvents.some(e => e.text.includes('Final'));
            const hasDescanso = state.matchEvents.some(e => e.text.includes('Descanso'));
            
            if (hasFinal) {
                prefix = 'FINAL';
            } else if (hasDescanso && !state.isMatchRunning) {
                prefix = 'DESCANSO';
            } else if (state.isMatchRunning) {
                prefix = time;
            } else if (state.matchEvents.length > 0) {
                prefix = `PAUSA ${time}`;
            }
            
            document.title = `${prefix} | ${score}`;
        },
        startQuarterDurationSelection() {
            const state = AppState.get();
            this.elements['quarter-duration-modal'].classList.add('visible');
            
            // Configurar botones de duraci√≥n
            [8, 10, 12].forEach(minutes => {
                const btn = this.elements[`quarter-${minutes}min`];
                if (btn) {
                    btn.onclick = () => {
                        AppConfig.QUARTER_DURATION_MINUTES = minutes;
                        AppConfig.QUARTER_DURATION_SECONDS = minutes * 60;
                        EventHandler.proceedAfterQuarterSelection();
                    };
                }
            });
        },
        updateTeamView() {
            // Mostrar ambos equipos siempre en la pizarra
            this.elements['local-bench'].classList.remove('hidden');
            this.elements['rival-bench'].classList.remove('hidden');
            this.elements['basketball-court'].querySelectorAll('.chip-on-pitch').forEach(chip => {
                chip.style.display = 'flex';
            });
        },
        calculateAvailableWindows() {
            const state = AppState.get();
            const { usedFirstHalf, usedSecondHalf } = state.substitutionWindows;
            const firstHalfAvailable = Math.max(0, AppConfig.MAX_SUBSTITUTION_WINDOWS - usedFirstHalf);
            
            if (state.currentQuarter <= 2) {
                return { firstHalf: firstHalfAvailable, secondHalf: 0 };
            }
            
            const maxSecondHalf = Math.max(0, AppConfig.MAX_SUBSTITUTION_WINDOWS_SECOND_HALF - usedFirstHalf);
            const secondHalfAvailable = Math.max(0, maxSecondHalf - usedSecondHalf);
            return { firstHalf: firstHalfAvailable, secondHalf: secondHalfAvailable };
        },
        updateSubstitutionWindowsUI() {
            const state = AppState.get();
            const { usedFirstHalf, usedSecondHalf } = state.substitutionWindows;

            const setupHalf = (container, usedCount, totalSlots, halfNumber) => {
                container.querySelectorAll('.window-box').forEach(box => box.remove());
                
                for (let i = 1; i <= totalSlots; i++) {
                    const box = document.createElement('span');
                    box.className = 'window-box';
                    
                    if (i <= usedCount) {
                        box.textContent = '‚úì';
                        box.classList.add('used', 'can-undo');
                        box.dataset.half = halfNumber;
                        box.onclick = () => EventHandler.handleUndoSubstitutionWindow(halfNumber);
                        box.title = 'Hacer clic para deshacer esta ventana';
                    } else {
                        box.textContent = '‚óã';
                    }
                    container.appendChild(box);
                }
            };
            
            const firstHalfContainer = this.elements['sub-windows-first-half'];
            const secondHalfContainer = this.elements['sub-windows-second-half'];
            const divider = this.elements['sub-windows-divider'];
            
            if (state.currentQuarter <= 2) {
                firstHalfContainer.classList.remove('hidden');
                divider.classList.add('hidden');
                secondHalfContainer.classList.add('hidden');
                setupHalf(firstHalfContainer, usedFirstHalf, AppConfig.MAX_SUBSTITUTION_WINDOWS, 1);
            } else {
                const maxSecondHalf = Math.max(0, AppConfig.MAX_SUBSTITUTION_WINDOWS - usedFirstHalf);
                
                if (usedFirstHalf > 0) {
                    firstHalfContainer.classList.remove('hidden');
                    divider.classList.remove('hidden');
                    setupHalf(firstHalfContainer, usedFirstHalf, usedFirstHalf, 1);
                } else {
                    firstHalfContainer.classList.add('hidden');
                    divider.classList.add('hidden');
                }
                
                if (maxSecondHalf > 0) {
                    secondHalfContainer.classList.remove('hidden');
                    setupHalf(secondHalfContainer, usedSecondHalf, maxSecondHalf, 2);
                } else {
                    secondHalfContainer.classList.add('hidden');
                }
            }
        },
    };

    const MatchLogic = {
        formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        },
        formatMinutesRoundedUp(seconds) {
            if (seconds === 0) return 0;
            return Math.ceil(seconds / 60);
        },
        generateEventText(event) {
            const state = AppState.get();
            const getTeamName = (team) => team === 'local' ? state.localTeamName : state.rivalTeamName;
            switch (event.type) {
                case 'basket':
                case 'goal':
                    const puntosText = event.puntos ? ` (${event.puntos} puntos)` : '';
                    return `CANASTA${puntosText} de <strong>${event.anotador || event.goleador}</strong>` + (event.asistente ? `. Asistencia de <strong>${event.asistente}</strong>` : '.');
                case 'substitution':
                    return `Sustituci√≥n (${getTeamName(event.team)}): <span style="color: var(--color-success);">‚¨ÜÔ∏è</span> <strong>${event.playerIn}</strong>, <span style="color: var(--color-danger);">‚¨áÔ∏è</span> <strong>${event.playerOut}</strong>.`;
                case 'shot':
                    return `TIRO de <strong>${event.player}</strong>.`;
                case 'foul':
                    return `Falta de <strong>${event.player}</strong>.`;
                case 'technical-foul':
                    return `Falta T√©cnica para <strong>${event.player}</strong>.`;
                case 'ejection':
                    return `EXPULSI√ìN para <strong>${event.player}</strong>.`;
                default: return event.text || '';
            }
        },
        initializeNewMatch() {
            const state = AppState.get();
            state.localTeamName = DOM.elements['local-name-input'].value.trim() || 'Local';
            state.rivalTeamName = DOM.elements['rival-name'].value.trim() || 'Rival';
            
            if (!state.eliminatedPlayers) {
                state.eliminatedPlayers = { local: [], rival: [] };
            }
            
            const newLocalPlayers = DOM.elements['local-players'].value.split(',').map(s => s.trim()).filter(Boolean);
            const newRivalDorsals = DOM.elements['rival-dorsals'].value.split(',').map(s => s.trim()).filter(Boolean);
            
            state.localPlayers = newLocalPlayers.filter(p => !state.eliminatedPlayers.local.includes(p));
            state.rivalDorsals = newRivalDorsals.filter(d => !state.eliminatedPlayers.rival.includes(d));
            
            if (state.localPlayers.length < AppConfig.MAX_PLAYERS_ON_PITCH || state.rivalDorsals.length < AppConfig.MAX_PLAYERS_ON_PITCH) {
                alert(`Se necesitan al menos ${AppConfig.MAX_PLAYERS_ON_PITCH} jugadores por equipo.`);
                return false;
            }
            this.initializeStats();
            return true;
        },
        initializeStats() {
            const state = AppState.get();
            state.playerStats = { local: {}, rival: {} };
            const initialStats = { onPitch: false, puntos: 0, asistencias: 0, rebotes: 0, robos: 0, tapones: 0, tiros: 0, faltas: 0, faltasTecnicas: 0, expulsiones: 0, minutosJugados: 0, expulsado: false, haSidoSustituido: false, position: null };
            state.localPlayers.forEach(p => state.playerStats.local[p] = { ...initialStats });
            state.rivalDorsals.forEach(d => state.playerStats.rival[d] = { ...initialStats });
        },
        checkStartingConditions() {
            const state = AppState.get();
            if (state.matchEvents.some(e => e.type === 'init_match')) return true;
            const localReady = Object.values(state.playerStats.local).filter(p => p.onPitch).length === AppConfig.MAX_PLAYERS_ON_PITCH;
            const rivalReady = Object.values(state.playerStats.rival).filter(p => p.onPitch).length === AppConfig.MAX_PLAYERS_ON_PITCH;
            return localReady && rivalReady;
        },
        _createTimerInterval() {
            const state = AppState.get();
            clearInterval(state.timerInterval);
            
            // Variable para rastrear el √∫ltimo tiempo en que se hizo rec√°lculo completo
            let lastFullRecalculation = state.matchTimer;
            const FULL_RECALCULATION_INTERVAL = 60; // Recalcular completamente cada 60 segundos
            
            state.timerInterval = setInterval(() => {
                if (!state.isMatchRunning) {
                    clearInterval(state.timerInterval);
                    state.timerInterval = null;
                    return;
                }
                
                const elapsedSeconds = Math.floor((Date.now() - state.timerStartTime) / 1000);
                const previousTimer = state.matchTimer;
                state.matchTimer = state.timerBaseTime + elapsedSeconds;

                // Optimizaci√≥n: Usar actualizaci√≥n incremental cuando sea posible
                const timeSinceFullRecalc = state.matchTimer - lastFullRecalculation;
                const timeDelta = state.matchTimer - previousTimer;
                
                if (state.matchTimer !== previousTimer) {
                    // Si ha pasado suficiente tiempo, hacer rec√°lculo completo para asegurar precisi√≥n
                    if (timeSinceFullRecalc >= FULL_RECALCULATION_INTERVAL) {
                        this.rebuildAndRecalculateAllState();
                        lastFullRecalculation = state.matchTimer;
                    } else if (timeDelta > 0 && timeDelta <= 5) {
                        // Actualizaci√≥n incremental para cambios peque√±os (m√°s eficiente)
                        this.adjustPlayerMinutes(timeDelta);
                        DOM.updateTimerDisplay();
                        DOM.updateStatsTables();
                    } else {
                        // Si el cambio es grande o inesperado, recalcular completamente
                        this.rebuildAndRecalculateAllState();
                        lastFullRecalculation = state.matchTimer;
                    }
                } else {
                    DOM.updateTimerDisplay();
                }
                
                // Verificar si ha llegado el fin del cuarto o final
                const quarterTimeLimit = state.currentQuarter * AppConfig.QUARTER_DURATION_SECONDS;
                if (state.matchTimer >= quarterTimeLimit && state.currentQuarter < AppConfig.MAX_QUARTERS) {
                    this.handleEndQuarter();
                } else if (state.currentQuarter >= AppConfig.MAX_QUARTERS && state.matchTimer >= quarterTimeLimit) {
                    this.handleFinishGame();
                }
                
                DOM.updateDocumentTitle();
                
                // Guardar estado con menos frecuencia para mejor rendimiento
                // Solo guardar cada 5 segundos o cuando sea cr√≠tico
                if (state.matchTimer % 5 === 0 || !state.isMatchRunning) {
                    AppState.save();
                }
            }, AppConfig.TIMER_INTERVAL_MS);
        },
        startTimer() {
            const state = AppState.get();
            if (state.isMatchRunning) return;
            state.isMatchRunning = true;
            state.timerStartTime = Date.now();
            state.timerBaseTime = state.matchTimer;
            this._createTimerInterval();
            DOM.updateButtonStates();
            AppState.save();
        },
        stopTimer() {
            const state = AppState.get();
            if (!state.isMatchRunning) return;
            const elapsedSeconds = Math.floor((Date.now() - state.timerStartTime) / 1000);
            state.matchTimer = state.timerBaseTime + elapsedSeconds;
            state.isMatchRunning = false;
            clearInterval(state.timerInterval);
            state.timerInterval = null;
            // CR√çTICO: Recalcular completamente al detener el timer
            // Esto asegura que los minutos jugados sean precisos
            this.rebuildAndRecalculateAllState();
            DOM.updateButtonStates();
            AppState.save();
        },
        adjustPlayerMinutes(seconds) {
            if (seconds <= 0) return;
            const state = AppState.get();
            // Sumar segundos jugados solo a los jugadores que est√°n actualmente en el campo
            Object.values(state.playerStats).forEach(team => {
                Object.values(team).forEach(player => {
                    if (player.onPitch && !player.expulsado) {
                        player.minutosJugados += seconds;
                    }
                });
            });
        },
        addMatchEvent(eventData) {
            const state = AppState.get();
            
            // Prevenir eventos duplicados de sustituci√≥n en el mismo tiempo
            if (eventData.type === 'substitution') {
                const duplicate = state.matchEvents.find(e => 
                    e.type === 'substitution' && 
                    e.team === eventData.team &&
                    e.playerIn === eventData.playerIn &&
                    e.playerOut === eventData.playerOut &&
                    Math.abs(e.timeInSeconds - state.matchTimer) < 2 // Mismo tiempo (2 segundos de margen)
                );
                if (duplicate) {
                    console.warn('Evento de sustituci√≥n duplicado detectado y omitido');
                    return;
                }
            }
            
            const event = { id: Date.now(), timeInSeconds: state.matchTimer, ...eventData };
            event.minute = Math.floor(event.timeInSeconds / 60);
            event.text = this.generateEventText(event);
            state.matchEvents.push(event); 
            state.matchEvents.sort((a, b) => a.timeInSeconds - b.timeInSeconds);
            AppState.save();
        },
        updateMatchEvent(eventId, updatedData) {
            const state = AppState.get();
            const eventIndex = state.matchEvents.findIndex(e => e.id == eventId);
            if (eventIndex !== -1) {
                let newEventData = { ...state.matchEvents[eventIndex], ...updatedData };
                newEventData.minute = Math.floor(newEventData.timeInSeconds / 60);
                newEventData.text = this.generateEventText(newEventData);
                state.matchEvents[eventIndex] = newEventData;
            }
            state.matchEvents.sort((a, b) => a.timeInSeconds - b.timeInSeconds);
            AppState.save();
        },
        rebuildAndRecalculateAllState() {
            const state = AppState.get();
            if (!state.initialPlayerState) return;

            // IMPORTANTE: Guardar las posiciones actuales que el usuario ha movido
            // antes de restaurar desde initialPlayerState
            const currentPositions = {};
            Object.keys(state.playerStats).forEach(team => {
                currentPositions[team] = {};
                Object.keys(state.playerStats[team]).forEach(playerName => {
                    const player = state.playerStats[team][playerName];
                    if (player.position) {
                        currentPositions[team][playerName] = { ...player.position };
                    }
                });
            });

            // Restaurar el estado inicial de los jugadores
            state.playerStats = JSON.parse(JSON.stringify(state.initialPlayerState));
            
            if (state.eliminatedPlayers) {
                state.eliminatedPlayers.local.forEach(playerName => {
                    delete state.playerStats.local[playerName];
                });
                state.eliminatedPlayers.rival.forEach(playerName => {
                    delete state.playerStats.rival[playerName];
                });
            }
            
            // Resetear todas las estad√≠sticas excepto onPitch y position
                const resetPlayerStats = {
                puntos: 0, asistencias: 0, rebotes: 0, robos: 0, tapones: 0, tiros: 0, faltas: 0,
                faltasTecnicas: 0, expulsiones: 0, expulsado: false, minutosJugados: 0
            };
            
            for (const team of Object.values(state.playerStats)) {
                for (const player of Object.values(team)) {
                    // Preservar onPitch y position del estado inicial
                    const preservedOnPitch = player.onPitch;
                    const preservedPosition = player.position ? { ...player.position } : null;
                    Object.assign(player, resetPlayerStats);
                    player.onPitch = preservedOnPitch;
                    player.position = preservedPosition;
                }
            }
            
            // CR√çTICO: Restaurar las posiciones actuales que el usuario ha movido
            // Esto asegura que las fichas se mantengan donde el usuario las coloc√≥
            Object.keys(currentPositions).forEach(team => {
                Object.keys(currentPositions[team]).forEach(playerName => {
                    if (state.playerStats[team] && state.playerStats[team][playerName]) {
                        state.playerStats[team][playerName].position = currentPositions[team][playerName];
                    }
                });
            });
            state.matchStats = { local: { corners: 0, offsides: 0 }, rival: { corners: 0, offsides: 0 } };
            
            // Si el partido no ha iniciado todav√≠a, no procesar eventos
            const hasStarted = state.matchEvents.some(e => e.type === 'init_match');
            if (!hasStarted) {
                DOM.updateAll();
                return;
            }

            // NUEVA L√ìGICA MEJORADA: Calcular minutos jugados de forma m√°s precisa
            // Filtrar y ordenar eventos v√°lidos hasta el tiempo actual
            const validEvents = state.matchEvents
                .filter(e => e.timeInSeconds >= 0 && e.timeInSeconds <= state.matchTimer)
                .sort((a, b) => a.timeInSeconds - b.timeInSeconds);
            
            // Encontrar el evento de inicio del partido
            const initMatchEvent = validEvents.find(e => e.type === 'init_match');
            if (!initMatchEvent) {
                DOM.updateAll();
                return;
            }
            
            let lastTime = initMatchEvent.timeInSeconds;
            let lastLocalSubTime = 0;
            
            // Procesar cada evento en orden cronol√≥gico
            for (const event of validEvents) {
                // Saltar eventos de control e init_match despu√©s del primero
                // PERO contar el tiempo jugado ANTES de ellos
                if (event.type === 'control' || (event.type === 'init_match' && event !== initMatchEvent)) {
                    // Contar el tiempo jugado hasta este evento de control
                    const timeDelta = event.timeInSeconds - lastTime;
                    if (timeDelta > 0) {
                        this.adjustPlayerMinutes(timeDelta);
                    }
                    lastTime = event.timeInSeconds;
                    continue;
                }
                
                // Si el evento ocurre antes del √∫ltimo tiempo procesado, saltarlo
                if (event.timeInSeconds < lastTime) {
                    continue;
                }
                
                // Calcular el delta de tiempo desde el √∫ltimo evento procesado
                const timeDelta = event.timeInSeconds - lastTime;
                
                // CR√çTICO: Sumar minutos jugados ANTES de procesar el evento
                // Esto asegura que los jugadores que est√°n en el campo cuenten su tiempo correctamente
                if (timeDelta > 0) {
                    this.adjustPlayerMinutes(timeDelta);
                }

                const teamPStats = state.playerStats[event.team];
                const playerStats = teamPStats?.[event.player];
                const matchTeamStats = state.matchStats[event.team];
                
                // Procesar el evento seg√∫n su tipo
                switch (event.type) {
                    case 'substitution':
                        if (event.team === 'local' && (event.timeInSeconds - lastLocalSubTime) > AppConfig.SUBSTITUTION_WINDOW_SECONDS) {
                            lastLocalSubTime = event.timeInSeconds;
                        }
                        const statsOut = teamPStats?.[event.playerOut];
                        const statsIn = teamPStats?.[event.playerIn];
                        
                        // Preservar la posici√≥n: si el jugador que entra ya tiene una posici√≥n guardada, mantenerla
                        // Si no, usar la del jugador que sale
                        let position = null;
                        if (statsIn?.position) {
                            position = { ...statsIn.position };
                        } else if (statsOut?.position) {
                            position = { ...statsOut.position };
                        }
                        
                        // El jugador que sale ya no est√° en el campo
                        this.setPlayerOnBench(event.playerOut, event.team);
                        // El jugador que entra ahora est√° en el campo
                        this.setPlayerOnPitch(event.playerIn, event.team, position);
                        break;
                    case 'ejection':
                        if (playerStats) {
                            playerStats.expulsiones++;
                            playerStats.expulsado = true;
                            this.setPlayerOnBench(event.player, event.team);
                        }
                        break;
                    case 'technical-foul':
                        if (playerStats) {
                            playerStats.faltasTecnicas++;
                            if (playerStats.faltasTecnicas >= 2) {
                                playerStats.expulsado = true;
                                this.setPlayerOnBench(event.player, event.team);
                            }
                        }
                        break;
                    case 'basket':
                    case 'goal':
                        const anotadorStats = teamPStats?.[event.anotador || event.goleador];
                        if (anotadorStats) {
                            anotadorStats.puntos += event.puntos || 2;
                            // Solo contar como tiro si no es tiro libre
                            if (event.basketType !== 'basket-1') {
                                anotadorStats.tiros++;
                            }
                        }
                        if (event.asistente && teamPStats?.[event.asistente]) {
                            teamPStats[event.asistente].asistencias++;
                        }
                        break;
                    case 'shot':
                        if (playerStats) {
                            playerStats.tiros++;
                        }
                        break;
                    case 'foul':
                        if (playerStats) {
                            playerStats.faltas++;
                        }
                        break;
                    case 'rebound':
                        if (playerStats) {
                            playerStats.rebotes++;
                        }
                        break;
                    case 'steal':
                        if (playerStats) {
                            playerStats.robos++;
                        }
                        break;
                    case 'block':
                        if (playerStats) {
                            playerStats.tapones++;
                        }
                        break;
                    case 'init_match':
                        // Ya procesado al inicio
                        break;
                }
                
                // Actualizar el tiempo del √∫ltimo evento procesado
                lastTime = event.timeInSeconds;
            }

            // CR√çTICO: Sumar el tiempo restante desde el √∫ltimo evento hasta el tiempo actual
            // Esto incluye cualquier tiempo de descuento o tiempo adicional
            const finalTimeDelta = state.matchTimer - lastTime;
            if (finalTimeDelta > 0) {
                this.adjustPlayerMinutes(finalTimeDelta);
            }
            
            // Actualizar el √∫ltimo minuto verificado
            state.lastMinuteCheck = Math.floor(state.matchTimer / 60);

            // Actualizar la interfaz
            DOM.updateAll();
        },
        setPlayerOnPitch(name, team, pos) {
            const stats = AppState.get().playerStats[team]?.[name];
            if (stats) {
                stats.onPitch = true;
                stats.position = pos;
            }
        },
        setPlayerOnBench(name, team) {
            const stats = AppState.get().playerStats[team]?.[name];
            if (stats) {
                stats.onPitch = false;
                stats.position = null;
            }
        },
        getMaxPlayersForTeam(team) {
            return AppConfig.MAX_PLAYERS_ON_PITCH - Object.values(AppState.get().playerStats[team]).filter(p => p.expulsado).length;
        }
    };

    const EventHandler = {
        ignoreNextClick: false,
        addEventListeners() {
            DOM.cacheElements();
            DOM.elements['start-config'].addEventListener('click', () => this.handleStartConfig());
            DOM.elements['btn-home'].addEventListener('click', () => window.location.href = 'index.html');
            DOM.elements.eventButtons.forEach(b => b.addEventListener('click', (e) => this.handleEventButtonClick(e)));
            DOM.elements['btn-end-quarter'].addEventListener('click', () => this.handleEndQuarter());
            DOM.elements['btn-start-next-quarter'].addEventListener('click', () => this.handleStartNextQuarter());
            DOM.elements['btn-finish-game'].addEventListener('click', () => this.handleFinishGame());
            DOM.elements['btn-reset-match'].addEventListener('click', () => this.handleResetMatch());
            DOM.elements['btn-new-match'].addEventListener('click', () => this.handleNewMatch());
            DOM.elements['btn-export-excel'].addEventListener('click', () => this.exportToCsv());
            DOM.elements['btn-toggle-timer'].addEventListener('click', () => this.handleToggleTimer());
            DOM.elements['minuto-actual'].addEventListener('click', () => this.handleTimeClick());
            this.addTimeEditorListeners();
            DOM.elements['cancel-edit-btn'].addEventListener('click', () => DOM.elements['edit-event-modal'].classList.remove('visible'));
            document.addEventListener('visibilitychange', () => this.handleVisibilityChange());
            
            document.addEventListener('click', (e) => {
                if (this.ignoreNextClick) {
                    this.ignoreNextClick = false;
                    return;
                }
                if (!DOM.elements['timeline-context-menu'].contains(e.target)) {
                    this.closeTimelineContextMenu();
                }
            });
        },
        openTimelineContextMenu(eventId, x, y) {
            this.closeTimelineContextMenu();
            this.ignoreNextClick = true;
            const menu = DOM.elements['timeline-context-menu'];
            menu.style.display = 'flex';
            
            // Ajustar posici√≥n para que no se salga de la pantalla
            const menuWidth = menu.offsetWidth;
            const menuHeight = menu.offsetHeight;
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight;

            let left = x;
            if (x + menuWidth > screenWidth) {
                left = screenWidth - menuWidth - 5;
            }
            let top = y;
            if (y + menuHeight > screenHeight) {
                top = screenHeight - menuHeight - 5;
            }

            menu.style.left = `${left}px`;
            menu.style.top = `${top}px`;

            DOM.elements['context-edit-btn'].onclick = () => {
                this.handleEditEvent(eventId);
                this.closeTimelineContextMenu();
            };
            DOM.elements['context-delete-btn'].onclick = () => {
                this.handleDeleteEvent(eventId);
                this.closeTimelineContextMenu();
            };
        },
        closeTimelineContextMenu() {
            DOM.elements['timeline-context-menu'].style.display = 'none';
            this.ignoreNextClick = false;
        },
        handleVisibilityChange() {
            const state = AppState.get();
            if (document.hidden) {
                if (state.isMatchRunning) AppState.save();
                return;
            }
            if (state.isMatchRunning) {
                const elapsedSeconds = Math.floor((Date.now() - state.timerStartTime) / 1000);
                state.matchTimer = state.timerBaseTime + elapsedSeconds;
                MatchLogic.rebuildAndRecalculateAllState();
            }
        },
        handleStartConfig() {
            AppState.init();
            if (MatchLogic.initializeNewMatch()) {
                DOM.showMatchUI();
                DOM.setupBenchesAndPitch();
                DOM.updateAll();
                DOM.startQuarterDurationSelection();
            }
        },
        proceedAfterQuarterSelection() {
            const state = AppState.get();
            
            // Colocar autom√°ticamente 5 jugadores de cada equipo en la pizarra
            DOM.placeInitialFivePlayers();
            
            DOM.updatePlayerChips();
            DOM.updateStatsTables();
            DOM.updateButtonStates();
            DOM.elements['quarter-duration-modal'].classList.remove('visible');
            AppState.get().initialPlayerState = JSON.parse(JSON.stringify(AppState.get().playerStats));
            AppState.save();
        },
        handleToggleTimer() {
            const state = AppState.get();
            if (!state.matchEvents.some(e => e.type === 'init_match')) {
                MatchLogic.addMatchEvent({ type: 'init_match', text: 'Inicio del partido.' });
                MatchLogic.startTimer();
            } else {
                if (state.isMatchRunning) {
                    MatchLogic.stopTimer();
                } else {
                    MatchLogic.startTimer();
                }
            }
        },
        handleEndQuarter() {
            MatchLogic.stopTimer();
            const state = AppState.get();
            const quarterTimeLimit = state.currentQuarter * AppConfig.QUARTER_DURATION_SECONDS;
            if (state.matchTimer < quarterTimeLimit) {
                state.matchTimer = quarterTimeLimit;
            }
            state.timerBaseTime = state.matchTimer;
            MatchLogic.addMatchEvent({ type: 'control', text: `Fin del ${state.currentQuarter}¬∫ cuarto.` });
            if (state.currentQuarter < AppConfig.MAX_QUARTERS) {
                state.currentQuarter++;
            }
            MatchLogic.rebuildAndRecalculateAllState();
        },
        handleStartNextQuarter() {
            MatchLogic.addMatchEvent({ type: 'control', text: `Inicio del ${AppState.get().currentQuarter}¬∫ cuarto.` });
            MatchLogic.startTimer();
        },
        handleFinishGame() {
            MatchLogic.stopTimer();
            const state = AppState.get();
            // Asegurar que el tiempo est√© al menos en el tiempo completo
            // Pero NO forzar si hay descuento - mantener el tiempo real jugado
            const fullTimeLimit = AppConfig.MAX_QUARTERS * AppConfig.QUARTER_DURATION_SECONDS;
            if (state.matchTimer < fullTimeLimit) {
                state.matchTimer = fullTimeLimit;
            }
            // El timerBaseTime debe ser el tiempo real jugado (puede incluir descuento)
            state.timerBaseTime = state.matchTimer;
            MatchLogic.addMatchEvent({ type: 'control', text: 'Final del partido.' });
            DOM.elements['btn-export-excel'].classList.remove('hidden');
            // CR√çTICO: Recalcular todos los minutos jugados hasta el final
            // Esto asegura que todos los jugadores tengan el tiempo correcto, incluyendo descuentos
            MatchLogic.rebuildAndRecalculateAllState();
            // Forzar actualizaci√≥n de todas las tablas despu√©s del rec√°lculo
            DOM.updateAll();
            AppState.save();
        },
        handleResetMatch() {
            if (confirm("¬øSeguro que quieres reiniciar? Se perder√°n todas las estad√≠sticas.")) {
                MatchLogic.stopTimer();
                const state = AppState.get();
                const conf = {
                    localTeamName: state.localTeamName,
                    rivalTeamName: state.rivalTeamName,
                    localPlayers: state.localPlayers,
                    rivalDorsals: state.rivalDorsals,
                    eliminatedPlayers: state.eliminatedPlayers
                };
                AppState.init();
                Object.assign(AppState.get(), conf);
                MatchLogic.initializeStats();
                DOM.setupBenchesAndPitch();
                DOM.updateAll();
                DOM.startQuarterDurationSelection();
                AppState.save();
            }
        },
        handleNewMatch() {
            if (confirm("¬øEmpezar un partido nuevo?")) {
                localStorage.removeItem(AppConfig.APP_STATE_KEY);
                location.reload();
            }
        },
        handleEventButtonClick(e) {
            const type = e.currentTarget.dataset.event;
            this.startPlayerEventFlow(type);
        },
        startPlayerEventFlow(type) {
            const state = AppState.get();
            state.eventFlow = { active: true, type, step: 1 };
            document.querySelector('main').classList.add('selecting-mode');
            DOM.elements['pitch-section'].scrollIntoView({ behavior: 'smooth', block: 'center' });
            let prompt = `Selecciona el jugador`;
            if (type === 'basket-3' || type === 'basket-2' || type === 'basket-1') prompt = "Selecciona al <strong>anotador</strong>";
            else if (type === 'shot') prompt = "Selecciona al <strong>tirador</strong>";
            else if (type === 'foul') prompt = "Selecciona al <strong>infractor</strong>";
            else if (type === 'technical-foul' || type === 'ejection') prompt = "Selecciona al jugador (campo o banquillo)";
            DOM.elements['event-flow-message'].innerHTML = `${prompt} <small>(clic aqu√≠ para cancelar)</small>`;
            DOM.elements['event-flow-message'].classList.remove('hidden');
            DOM.elements['event-flow-message'].onclick = () => this.endEventFlow(true);
        },
        startTeamEventFlow(type) {
            const state = AppState.get();
            state.eventFlow = { active: true, type, step: 1 };
            DOM.elements['quarter-duration-modal-title'].innerHTML = `¬øPara qu√© equipo es el evento?`;
            const buttonsContainer = DOM.elements['quarter-duration-buttons'];
            buttonsContainer.innerHTML = '';
            ['local', 'rival'].forEach(team => {
                const btn = document.createElement('button');
                btn.textContent = team === 'local' ? state.localTeamName : state.rivalTeamName;
                btn.className = team === 'local' ? 'btn-primary' : 'btn-danger';
                btn.onclick = () => {
                    MatchLogic.addMatchEvent({ type, team });
                    this.endEventFlow();
                };
                buttonsContainer.appendChild(btn);
            });
            DOM.elements['quarter-duration-modal'].classList.add('visible');
        },
        processEventSelection(chip) {
            const state = AppState.get();
            if (!state.eventFlow.active) return;
            const { type, step } = state.eventFlow;
            const { name, team } = chip.dataset;
            const isCardEvent = type === 'technical-foul' || type === 'ejection';
            if (!isCardEvent && !chip.classList.contains('chip-on-pitch')) return;
            
            if ((type === 'basket-3' || type === 'basket-2' || type === 'basket-1') && step === 1) {
                const puntos = type === 'basket-3' ? 3 : type === 'basket-2' ? 2 : 1;
                state.eventFlow = { ...state.eventFlow, step: 2, anotador: name, team, puntos, basketType: type };
                DOM.elements['event-flow-message'].innerHTML = `CANASTA de <strong>${name}</strong> (${puntos} puntos). Selecciona al <strong>asistente</strong> (o clic en el anotador si no hay).`;
            } else if ((type === 'basket-3' || type === 'basket-2' || type === 'basket-1') && step === 2) {
                const { anotador, team, puntos, basketType } = state.eventFlow;
                const asistente = name !== anotador ? name : null;
                MatchLogic.addMatchEvent({ type: 'basket', anotador, asistente, team, puntos, basketType });
                this.endEventFlow();
            } else {
                MatchLogic.addMatchEvent({ type, player: name, team });
                this.endEventFlow();
            }
        },
        endEventFlow(cancelled = false) {
            document.querySelector('main').classList.remove('selecting-mode');
            DOM.elements['event-flow-message'].classList.add('hidden');
            DOM.elements['quarter-duration-modal'].classList.remove('visible');
            AppState.get().eventFlow = { active: false };
            if (!cancelled) MatchLogic.rebuildAndRecalculateAllState();
        },
        handleDeleteEvent(eventId) {
            if (confirm("¬øEst√°s seguro de que quieres eliminar este evento?")) {
                const state = AppState.get();
                const eventToDelete = state.matchEvents.find(e => e.id == eventId);

                if (!eventToDelete) return;

                const shouldPreserveWindows = eventToDelete.type === 'substitution';
                let preservedWindows = null;
                if (shouldPreserveWindows) {
                    preservedWindows = { ...state.substitutionWindows };
                }

                state.matchEvents = state.matchEvents.filter(e => e.id != eventId);
                
                MatchLogic.rebuildAndRecalculateAllState();

                if (shouldPreserveWindows && preservedWindows) {
                    state.substitutionWindows = preservedWindows;
                    DOM.updateSubstitutionWindowsUI();
                }

                AppState.save();
            }
        },
        handleEditEvent(eventId) {
            const state = AppState.get();
            const eventToEdit = state.matchEvents.find(e => e.id == eventId);
            if (!eventToEdit) return;

            const modal = DOM.elements['edit-event-modal'];
            const titleEl = DOM.elements['edit-event-title'];
            const contentEl = DOM.elements['edit-event-content'];
            contentEl.innerHTML = '';

            const createSelect = (id, label, options, selected) => 
                `<label for="${id}">${label}</label>
                <select id="${id}">${options.map(o => 
                    `<option value="${o}" ${o === selected ? 'selected' : ''}>${o}</option>`
                ).join('')}</select>`;
                
            const createTimeInput = (id, label, timeInSeconds) => {
                const mins = Math.floor(timeInSeconds / 60);
                const secs = timeInSeconds % 60;
                return `<label>${label}</label>
                    <div class="time-editor-container">
                        <div class="time-editor-unit">
                            <div class="time-editor-buttons">
                                <button type="button" id="${id}-min-plus">+</button>
                                <button type="button" id="${id}-min-minus">-</button>
                            </div>
                            <input type="number" id="${id}-min" value="${mins}" min="0" max="${AppConfig.MAX_TIME_MINUTES}">
                        </div>
                        <span class="time-editor-separator">:</span>
                        <div class="time-editor-unit">
                            <input type="number" id="${id}-sec" value="${secs}" min="0" max="${AppConfig.MAX_TIME_SECONDS}">
                            <div class="time-editor-buttons">
                                <button type="button" id="${id}-sec-plus">+</button>
                                <button type="button" id="${id}-sec-minus">-</button>
                            </div>
                        </div>
                    </div>`;
            };

            const eventTypeMap = {
                'goal': 'Gol',
                'shot': 'Disparo',
                'foul': 'Falta',
                'yellow-card': 'Tarjeta Amarilla',
                'red-card': 'Tarjeta Roja',
                'substitution': 'Sustituci√≥n'
            };
            titleEl.textContent = `Editar ${eventTypeMap[eventToEdit.type] || 'Evento'}`;
            
            const allPlayers = [...state.localPlayers, ...state.rivalDorsals];

            switch (eventToEdit.type) {
                case 'goal':
                    contentEl.innerHTML += createSelect('edit-goleador', 'Goleador:', allPlayers, eventToEdit.goleador);
                    contentEl.innerHTML += createSelect('edit-asistente', 'Asistente:', ['Sin Asistencia', ...allPlayers], eventToEdit.asistente || 'Sin Asistencia');
                    break;
                case 'substitution':
                    const teamForSub = state.localPlayers.includes(eventToEdit.playerIn || eventToEdit.playerOut) ? 'local' : 'rival';
                    const playersForSub = teamForSub === 'local' ? state.localPlayers : state.rivalDorsals;
                    contentEl.innerHTML += createSelect('edit-player-in', 'Entra:', playersForSub, eventToEdit.playerIn);
                    contentEl.innerHTML += createSelect('edit-player-out', 'Sale:', playersForSub, eventToEdit.playerOut);
                    break;
                default:
                    contentEl.innerHTML += createSelect('edit-player', 'Jugador:', allPlayers, eventToEdit.player);
                    break;
            }
            contentEl.innerHTML += createTimeInput('edit-time', 'Minuto del Evento:', eventToEdit.timeInSeconds);
            
            EventHandler.setupTimeEditorListeners('edit-time');

            DOM.elements['save-edit-btn'].onclick = () => {
                let updatedData = {};
                const newMin = parseInt(document.getElementById('edit-time-min').value) || 0;
                const newSec = parseInt(document.getElementById('edit-time-sec').value) || 0;
                updatedData.timeInSeconds = (newMin * 60) + newSec;
                
                switch (eventToEdit.type) {
                    case 'goal':
                        updatedData.goleador = document.getElementById('edit-goleador').value;
                        updatedData.asistente = document.getElementById('edit-asistente').value;
                        if (updatedData.asistente === 'Sin Asistencia') {
                            updatedData.asistente = null;
                        }
                        updatedData.team = state.localPlayers.includes(updatedData.goleador) ? 'local' : 'rival';
                        break;
                    case 'substitution':
                        updatedData.playerIn = document.getElementById('edit-player-in').value;
                        updatedData.playerOut = document.getElementById('edit-player-out').value;
                        updatedData.team = state.localPlayers.includes(updatedData.playerIn) ? 'local' : 'rival';
                        break;
                    default:
                        updatedData.player = document.getElementById('edit-player').value;
                        updatedData.team = state.localPlayers.includes(updatedData.player) ? 'local' : 'rival';
                        break;
                }
                
                MatchLogic.updateMatchEvent(eventId, updatedData);
                modal.classList.remove('visible');
                MatchLogic.rebuildAndRecalculateAllState();
            };
            modal.classList.add('visible');
        },
        handleUndoSubstitutionWindow(halfNumber) {
            if (confirm("¬øEst√°s seguro de que quieres deshacer el uso de esta ventana de cambio? Esto NO afectar√° a la cronolog√≠a del partido.")) {
                const state = AppState.get();
                if (halfNumber == 1 && state.substitutionWindows.usedFirstHalf > 0) {
                    state.substitutionWindows.usedFirstHalf--;
                } else if (halfNumber == 2 && state.substitutionWindows.usedSecondHalf > 0) {
                    state.substitutionWindows.usedSecondHalf--;
                }
                DOM.updateSubstitutionWindowsUI();
                AppState.save();
            }
        },
        handleTimeClick() {
            const state = AppState.get();
            if (!state.isMatchRunning && state.matchEvents.some(e => e.type === 'init_match')) {
                const mins = Math.floor(state.matchTimer / 60);
                const secs = state.matchTimer % 60;
                DOM.elements['time-editor-min'].value = mins.toString().padStart(2,'0');
                DOM.elements['time-editor-sec'].value = secs.toString().padStart(2,'0');
                DOM.elements['time-editor-modal'].classList.add('visible');
            }
        },
        setupTimeEditorListeners(prefix) {
            const minInput = document.getElementById(`${prefix}-min`);
            const secInput = document.getElementById(`${prefix}-sec`);
            
            if (!minInput || !secInput) return;

            const updateValue = (input, delta) => {
                let value = parseInt(input.value) || 0;
                value += delta;
                
                if (input === minInput) {
                    value = Math.max(0, Math.min(value, AppConfig.MAX_TIME_MINUTES));
                } else if (input === secInput) {
                    if (value < 0) {
                        value = AppConfig.MAX_TIME_SECONDS;
                        updateValue(minInput, -1);
                    } else if (value > AppConfig.MAX_TIME_SECONDS) {
                        value = 0;
                        updateValue(minInput, 1);
                    }
                }
                input.value = value.toString().padStart(2, '0');
            };

            const minPlus = document.getElementById(`${prefix}-min-plus`);
            const minMinus = document.getElementById(`${prefix}-min-minus`);
            const secPlus = document.getElementById(`${prefix}-sec-plus`);
            const secMinus = document.getElementById(`${prefix}-sec-minus`);

            if (minPlus) minPlus.addEventListener('click', () => updateValue(minInput, 1));
            if (minMinus) minMinus.addEventListener('click', () => updateValue(minInput, -1));
            if (secPlus) secPlus.addEventListener('click', () => updateValue(secInput, 1));
            if (secMinus) secMinus.addEventListener('click', () => updateValue(secInput, -1));
        },
        addTimeEditorListeners() {
            this.setupTimeEditorListeners('time-editor');

            DOM.elements['save-time-btn'].addEventListener('click', () => {
                const minInput = DOM.elements['time-editor-min'];
                const secInput = DOM.elements['time-editor-sec'];
                const newMins = parseInt(minInput.value) || 0;
                const newSecs = parseInt(secInput.value) || 0;
                const newTotalSeconds = (newMins * 60) + newSecs;
                
                const state = AppState.get();
                const lastEventTime = state.matchEvents
                    .filter(e => e.type !== 'control')
                    .at(-1)?.timeInSeconds || 0;
                    
                if (newTotalSeconds < lastEventTime) {
                    alert("El tiempo no puede ser anterior al √∫ltimo evento registrado.");
                    return;
                }
                
                // Actualizar el tiempo del partido
                state.matchTimer = newTotalSeconds;
                state.timerBaseTime = newTotalSeconds;
                
                // Si el partido estaba corriendo, actualizar el timerStartTime
                // para que contin√∫e desde el nuevo tiempo
                if (state.isMatchRunning) {
                    state.timerStartTime = Date.now();
                }
                
                // Recalcular todos los minutos jugados bas√°ndose en el nuevo tiempo
                MatchLogic.rebuildAndRecalculateAllState();
                AppState.save();
                DOM.elements['time-editor-modal'].classList.remove('visible');
            });
            
            DOM.elements['cancel-time-btn'].addEventListener('click', () => 
                DOM.elements['time-editor-modal'].classList.remove('visible')
            );
        },
        exportToCsv() {
            try {
                const state = AppState.get();
                
                // Asegurar que los minutos est√°n calculados correctamente antes de exportar
                MatchLogic.rebuildAndRecalculateAllState();
                
                const formatPlayerRow = (player, stats) => {
                    const statsObj = stats || {};
                    return [
                        player || '',
                        statsObj.goles || 0,
                        statsObj.asistencias || 0,
                        statsObj.disparos || 0,
                        statsObj.faltas || 0,
                        statsObj.amarillas || 0,
                        statsObj.rojas || 0,
                        MatchLogic.formatMinutesRoundedUp(statsObj.minutosJugados || 0)
                    ].join(",");
                };
                
                const lines = [
                    `${state.localTeamName || 'Local'}`,
                    'Jugador,G,A,D,F,Y,R,MIN',
                    ...(state.localPlayers || []).map(p => formatPlayerRow(p, state.playerStats?.local?.[p])),
                    '',
                    `${state.rivalTeamName || 'Rival'}`,
                    'Dorsal,G,A,D,F,Y,R,MIN',
                    ...(state.rivalDorsals || []).map(d => formatPlayerRow(d, state.playerStats?.rival?.[d])),
                    '',
                    'Cronolog√≠a del Partido',
                    'Minuto,Evento',
                    ...(state.matchEvents || []).map(e => 
                        `${e.minute || 0},"${(e.text || '').replace(/<[^>]*>?/gm, '').replace(/"/g, '""')}"`
                    )
                ];
                
                const csv = lines.join('\n');
                const blob = new Blob(["\uFEFF" + csv], { type: 'text/csv;charset=utf-8;' });
                const a = document.createElement("a");
                const url = URL.createObjectURL(blob);
                a.href = url;
                a.download = `estadisticas_${(state.localTeamName || 'Local').replace(/[^a-zA-Z0-9]/g, '_')}_vs_${(state.rivalTeamName || 'Rival').replace(/[^a-zA-Z0-9]/g, '_')}.csv`;
                
                // Agregar el elemento al DOM temporalmente para asegurar compatibilidad
                document.body.appendChild(a);
                a.click();
                
                // Esperar antes de revocar la URL para asegurar que el navegador descargue el archivo
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 1000);
            } catch (error) {
                console.error('Error al exportar a CSV:', error);
                alert('Error al exportar el archivo. Por favor, int√©ntalo de nuevo.');
            }
        },
    };

    const DragAndDrop = {
        draggedElement: null,
        isDragging: false,
        offsetX: 0,
        offsetY: 0,
        start(e) {
            const el = e.currentTarget;
            const stats = AppState.get().playerStats[el.dataset.team]?.[el.dataset.name];
            if (!el || (stats && stats.expulsado) || AppState.get().eventFlow.active) {
                return;
            }
            e.preventDefault();
            this.draggedElement = el;
            this.isDragging = false;
            const rect = el.getBoundingClientRect();
            this.offsetX = e.clientX - rect.left;
            this.offsetY = e.clientY - rect.top;
            document.addEventListener('pointermove', this.move);
            document.addEventListener('pointerup', this.end);
        },
        move(e) {
            if (!this.draggedElement) return;
            e.preventDefault();
            const dragDistance = Math.sqrt(
                (e.clientX - (this.draggedElement.getBoundingClientRect().left + this.offsetX)) ** 2 +
                (e.clientY - (this.draggedElement.getBoundingClientRect().top + this.offsetY)) ** 2
            );
            if (!this.isDragging && dragDistance > AppConfig.DRAG_THRESHOLD_PX) {
                this.isDragging = true;
                this.draggedElement.classList.add('dragging');
                document.body.appendChild(this.draggedElement);
            }
            if (this.isDragging) {
                this.draggedElement.style.left = `${e.clientX - this.offsetX}px`;
                this.draggedElement.style.top = `${e.clientY - this.offsetY}px`;
            }
        },
        end(e) {
            document.removeEventListener('pointermove', this.move);
            document.removeEventListener('pointerup', this.end);
            if (!this.draggedElement) return;
            if (this.isDragging) {
                this.draggedElement.style.display = 'none';
                const dropTarget = document.elementFromPoint(e.clientX, e.clientY);
                this.draggedElement.style.display = '';
                this.executeDrop(dropTarget, e.clientX, e.clientY);
            }
            this.draggedElement.classList.remove('dragging');
            this.draggedElement = null;
            DOM.updateAll();
        },
        executeDrop(target, clientX, clientY) {
            const dragged = this.draggedElement;
            const state = AppState.get();
            const stats = state.playerStats[dragged.dataset.team][dragged.dataset.name];
            const targetChip = target?.closest('.player-chip');
            const targetZone = target?.closest('#basketball-court, .bench');
            
            if (targetChip && targetChip !== dragged && dragged.dataset.team === targetChip.dataset.team) {
                this.handlePlayerSwap(dragged, targetChip);
            } else if (targetZone?.id === 'basketball-court') {
                const maxPlayers = MatchLogic.getMaxPlayersForTeam(dragged.dataset.team);
                const teamPlayersOnPitch = Object.values(state.playerStats[dragged.dataset.team]).filter(p => p.onPitch).length;
                if (teamPlayersOnPitch >= maxPlayers && !stats.onPitch) {
                    alert(`Este equipo solo puede tener ${maxPlayers} jugadores en el campo.`);
                } else {
                    const rect = targetZone.getBoundingClientRect();
                    const pos = {
                        left: `${100 * (clientX - rect.left) / rect.width}%`,
                        top: `${100 * (clientY - rect.top) / rect.height}%`
                    };
                    MatchLogic.setPlayerOnPitch(dragged.dataset.name, dragged.dataset.team, pos);
                    // Actualizar el estado inicial para preservar esta posici√≥n
                    if (state.initialPlayerState) {
                        const initialStats = state.initialPlayerState[dragged.dataset.team]?.[dragged.dataset.name];
                        if (initialStats) {
                            initialStats.position = { ...pos };
                        }
                    }
                }
            } else if (targetZone?.classList.contains('bench')) {
                if (state.matchEvents.some(e => e.type === 'init_match')) {
                    alert("Para hacer un cambio durante el partido, arrastra un jugador del banquillo sobre uno del campo.");
                } else {
                    if (targetZone.id === `${dragged.dataset.team}-bench`) {
                        MatchLogic.setPlayerOnBench(dragged.dataset.name, dragged.dataset.team);
                    }
                }
            }
            AppState.save();
        },
        handlePlayerSwap(playerInEl, playerOutEl) {
            const state = AppState.get();
            const team = playerInEl.dataset.team;
            const playerInName = playerInEl.dataset.name;
            const playerOutName = playerOutEl.dataset.name;
            const statsIn = state.playerStats[team][playerInName];
            const statsOut = state.playerStats[team][playerOutName];
            
            if (!state.matchEvents.some(e => e.type === 'init_match')) {
                const posIn = {...statsIn.position};
                const onPitchIn = statsIn.onPitch;
                statsIn.position = {...statsOut.position};
                statsIn.onPitch = statsOut.onPitch;
                statsOut.position = posIn;
                statsOut.onPitch = onPitchIn;
                state.initialPlayerState = JSON.parse(JSON.stringify(state.playerStats));
            } else if (statsIn.onPitch !== statsOut.onPitch) {
                // Durante el partido: intercambio de posiciones en sustituciones
                // Preservar las posiciones que el usuario ha movido
                const posIn = statsIn.position ? {...statsIn.position} : null;
                const posOut = statsOut.position ? {...statsOut.position} : null;
                
                // Intercambiar posiciones si ambas existen
                if (posIn && posOut) {
                    statsIn.position = posOut;
                    statsOut.position = posIn;
                } else if (posOut) {
                    // Si solo el que sale tiene posici√≥n, d√°rsela al que entra
                    statsIn.position = posOut;
                } else if (posIn) {
                    // Si solo el que entra tiene posici√≥n, d√°rsela al que sale
                    statsOut.position = posIn;
                }
                
                // Actualizar initialPlayerState para preservar las nuevas posiciones
                if (state.initialPlayerState) {
                    const initialStatsIn = state.initialPlayerState[team]?.[playerInName];
                    const initialStatsOut = state.initialPlayerState[team]?.[playerOutName];
                    if (initialStatsIn && statsIn.position) {
                        initialStatsIn.position = {...statsIn.position};
                    }
                    if (initialStatsOut && statsOut.position) {
                        initialStatsOut.position = {...statsOut.position};
                    }
                }
                const onPitchPlayerName = statsIn.onPitch ? playerInName : playerOutName;
                const onBenchPlayerName = statsIn.onPitch ? playerOutName : playerInName;
                
                // Verificar y contar ventanas para el equipo local
                if (team === 'local') {
                    const localSubs = state.matchEvents.filter(e => e.type === 'substitution' && e.team === 'local');
                    const lastLocalSub = localSubs[localSubs.length - 1];
                    const isNewWindow = !lastLocalSub || (state.matchTimer - lastLocalSub.timeInSeconds) > AppConfig.SUBSTITUTION_WINDOW_SECONDS;
                    
                        if (isNewWindow) {
                            const { usedFirstHalf, usedSecondHalf } = state.substitutionWindows;
                            const totalUsed = usedFirstHalf + usedSecondHalf;
                            
                            if (totalUsed >= AppConfig.MAX_SUBSTITUTION_WINDOWS) {
                                alert(`Has agotado las ${AppConfig.MAX_SUBSTITUTION_WINDOWS} ventanas de cambios del partido.`);
                                return;
                            }
                            
                            if (state.currentQuarter <= 2) {
                                if (usedFirstHalf >= AppConfig.MAX_SUBSTITUTION_WINDOWS) {
                                    alert(`Has agotado las ${AppConfig.MAX_SUBSTITUTION_WINDOWS} ventanas de cambios de la primera parte.`);
                                    return;
                                }
                                state.substitutionWindows.usedFirstHalf++;
                            } else {
                                const maxSecondHalf = AppConfig.MAX_SUBSTITUTION_WINDOWS - usedFirstHalf;
                                if (usedSecondHalf >= maxSecondHalf) {
                                    alert(`Has agotado las ventanas de cambios para la 2¬™ parte. Disponibles: ${maxSecondHalf}`);
                                    return;
                                }
                                state.substitutionWindows.usedSecondHalf++;
                            }
                        }
                }
                
                MatchLogic.addMatchEvent({ type: 'substitution', playerIn: onBenchPlayerName, playerOut: onPitchPlayerName, team });
                MatchLogic.rebuildAndRecalculateAllState();
            } else if (statsIn.onPitch && statsOut.onPitch) {
                // Intercambio de posiciones entre dos jugadores en el campo
                const posIn = statsIn.position ? {...statsIn.position} : null;
                const posOut = statsOut.position ? {...statsOut.position} : null;
                
                if (posIn && posOut) {
                    statsIn.position = posOut;
                    statsOut.position = posIn;
                }
                
                // Actualizar el estado inicial para conservar los cambios de posici√≥n
                if (state.initialPlayerState) {
                    const initialStatsIn = state.initialPlayerState[team]?.[playerInName];
                    const initialStatsOut = state.initialPlayerState[team]?.[playerOutName];
                    if (initialStatsIn && statsIn.position) {
                        initialStatsIn.position = {...statsIn.position};
                    }
                    if (initialStatsOut && statsOut.position) {
                        initialStatsOut.position = {...statsOut.position};
                    }
                }
            }
            AppState.save();
        }
    };

    document.addEventListener('DOMContentLoaded', () => {
        DragAndDrop.move = DragAndDrop.move.bind(DragAndDrop);
        DragAndDrop.end = DragAndDrop.end.bind(DragAndDrop);
        EventHandler.addEventListeners();

        if (AppState.load()) {
            DOM.showMatchUI();
            const state = AppState.get();
            // Solo configurar bancos si no hay jugadores eliminados o si es la primera vez
            if (!state.eliminatedPlayers || (state.eliminatedPlayers.local.length === 0 && state.eliminatedPlayers.rival.length === 0)) {
                DOM.setupBenchesAndPitch();
            } else {
                // Recrear solo los jugadores no eliminados
                DOM.setupBenchesAndPitch();
            }
            
            if (state.isMatchRunning) {
                const elapsedSinceSave = Math.floor((Date.now() - state.timerStartTime) / 1000);
                state.matchTimer = state.timerBaseTime + elapsedSinceSave;
                MatchLogic._createTimerInterval();
            }

            if (state.initialPlayerState) {
                MatchLogic.rebuildAndRecalculateAllState();
            } else {
                DOM.updateAll();
            }
        } else {
            AppState.init();
        }
    });
</script>
</body>
</html>
</html>